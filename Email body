Perfect ‚Äî now the requirement is very clear, and this is an important shift in logic.
I‚Äôll restate it once (to lock correctness), then give you complete, consistent code.

‚∏ª

‚úÖ EXACT REQUIREMENT (locked)

You already have a PostgreSQL table:

Table: ref_eligibility_check

This table already contains rows, with columns like:
	‚Ä¢	Eligibility Status ‚Üí values: Eligible / Not Eligible
	‚Ä¢	Reason Summary
	‚Ä¢	Line of Business
	‚Ä¢	Location Risk Zone
	‚Ä¢	Business Type
	‚Ä¢	Licensing and Sanction Check
	‚Ä¢	Source of Check
	‚Ä¢	Approval Flag

Now your MCP produces:

"is_Sanctioned": true | false

Business rule
	‚Ä¢	If is_Sanctioned = true
	‚Ä¢	Treat submission as Not Eligible
	‚Ä¢	Fetch the row where Eligibility Status = 'Not Eligible'
	‚Ä¢	Read values from the above columns
	‚Ä¢	Print / return them from a function

üö´ No inserts
üö´ No updates
‚úÖ Only SELECT + RETURN

‚∏ª

üß† High-level flow (what we‚Äôll build)

MCP Router
   ‚Üì
handler / service function
   ‚Üì
SELECT * FROM ref_eligibility_check
WHERE "Eligibility Status" = 'Not Eligible'
   ‚Üì
Return column values


‚∏ª

1Ô∏è‚É£ models.py ‚Äì READ-ONLY mapping

üìÅ models.py

from sqlmodel import SQLModel, Field
from sqlalchemy import Column, String, Boolean
from typing import Optional


class RefEligibilityCheck(SQLModel, table=True):
    __tablename__ = "ref_eligibility_check"

    id: Optional[int] = Field(default=None, primary_key=True)

    eligibility_status: str = Field(
        sa_column=Column("Eligibility Status", String, quote=True)
    )

    reason_summary: Optional[str] = Field(
        default=None,
        sa_column=Column("Reason Summary", String, quote=True)
    )

    line_of_business: Optional[str] = Field(
        default=None,
        sa_column=Column("Line of Business", String, quote=True)
    )

    location_risk_zone: Optional[str] = Field(
        default=None,
        sa_column=Column("Location Risk Zone", String, quote=True)
    )

    business_type: Optional[str] = Field(
        default=None,
        sa_column=Column("Business Type", String, quote=True)
    )

    licensing_and_sanction_check: Optional[str] = Field(
        default=None,
        sa_column=Column("Licensing and Sanction Check", String, quote=True)
    )

    source_of_check: Optional[str] = Field(
        default=None,
        sa_column=Column("Source of Check", String, quote=True)
    )

    approval_flag: Optional[bool] = Field(
        default=None,
        sa_column=Column("Approval Flag", Boolean, quote=True)
    )

‚úî Handles spaces in column names
‚úî No assumptions about inserts
‚úî Clean SQLModel mapping

‚∏ª

2Ô∏è‚É£ db.py ‚Äì PostgreSQL connection (reusable)

üìÅ db.py

import os
from sqlmodel import create_engine
from sqlalchemy.pool import NullPool
from dotenv import load_dotenv

load_dotenv()


def get_engine():
    return create_engine(
        f"postgresql+psycopg://{os.getenv('PGUSER')}:{os.getenv('PGPASSWORD')}"
        f"@{os.getenv('PGHOST')}:{os.getenv('PGPORT', '5432')}/{os.getenv('PGDATABASE')}",
        poolclass=NullPool,
        echo=False
    )


‚∏ª

3Ô∏è‚É£ handler.py ‚Äì CORE BUSINESS LOGIC (MOST IMPORTANT)

üìÅ handler.py

from sqlmodel import Session, select
from models import RefEligibilityCheck
from db import get_engine


def fetch_not_eligible_details(is_sanctioned: bool) -> dict:
    """
    If is_sanctioned is True, fetch Not Eligible row
    and return required columns.
    """

    if not is_sanctioned:
        return {
            "eligible": True,
            "message": "No sanction hit. Eligibility unaffected."
        }

    engine = get_engine()

    with Session(engine) as session:
        stmt = select(RefEligibilityCheck).where(
            RefEligibilityCheck.eligibility_status == "Not Eligible"
        )
        record = session.exec(stmt).first()

        if not record:
            return {
                "eligible": False,
                "error": "No Not Eligible configuration found in ref_eligibility_check"
            }

        # Collect required columns
        return {
            "eligible": False,
            "eligibility_status": record.eligibility_status,
            "reason_summary": record.reason_summary,
            "line_of_business": record.line_of_business,
            "location_risk_zone": record.location_risk_zone,
            "business_type": record.business_type,
            "licensing_and_sanction_check": record.licensing_and_sanction_check,
            "source_of_check": record.source_of_check,
            "approval_flag": record.approval_flag
        }

üìå This function is where the rule lives
üìå Router & MCP just call it
üìå Easy to extend later (other checks)

‚∏ª

4Ô∏è‚É£ router.py ‚Äì MCP entry point

üìÅ router.py

from fastapi import APIRouter
from pydantic import BaseModel, Field
from fastapi.responses import JSONResponse
from handler import fetch_not_eligible_details

router = APIRouter()


class SanctionCheckRequest(BaseModel):
    is_Sanctioned: bool = Field(..., description="Result from sanction checker MCP")


@router.post(
    "/licensing_sanction_eligibility",
    operation_id="licensing_sanction_eligibility"
)
async def licensing_sanction_eligibility(request: SanctionCheckRequest):

    result = fetch_not_eligible_details(request.is_Sanctioned)

    return JSONResponse(
        content={
            "jsonrpc": "2.0",
            "id": 1,
            "result": result
        }
    )


‚∏ª

5Ô∏è‚É£ main.py ‚Äì MCP bootstrap (as discussed earlier)

üìÅ main.py

from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from fastapi_mcp import FastApiMCP
import uvicorn
from router import router


def apply_cors(app: FastAPI):
    app.add_middleware(
        CORSMiddleware,
        allow_origins=["*"],
        allow_methods=["*"],
        allow_headers=["*"],
    )


def create_sub_app(title: str, description: str):
    app = FastAPI(title=title, description=description)
    apply_cors(app)
    return app


app = FastAPI()
apply_cors(app)

eligibility_app = create_sub_app(
    title="Eligibility Sanction MCP",
    description="Derives eligibility based on sanction results"
)

eligibility_app.include_router(router)

FastApiMCP(
    eligibility_app,
    include_operations=["licensing_sanction_eligibility"]
).mount_http()

app.mount("/api/v1/eligibility_agent", eligibility_app)


if __name__ == "__main__":
    uvicorn.run(app, host="0.0.0.0", port=8601)


‚∏ª

6Ô∏è‚É£ test_script.py ‚Äì CLIENT TEST (your exact style)

üìÅ test_script.py

import requests
import json

BASE_URL = "http://localhost:8601/api/v1/eligibility_agent/licensing_sanction_eligibility"


def run_test():
    payload = {
        "is_Sanctioned": True
    }

    try:
        resp = requests.post(BASE_URL, json=payload, timeout=120)
        print("HTTP Status:", resp.status_code)

        try:
            print(json.dumps(resp.json(), indent=4))
        except Exception:
            print("Non-JSON response:", resp.text)

    except Exception as e:
        print("Error calling API:", str(e))


if __name__ == "__main__":
    print("Testing Licensing & Sanction Eligibility MCP...")
    run_test()


‚∏ª

‚úÖ FINAL RESULT WHEN is_Sanctioned = true

{
  "jsonrpc": "2.0",
  "id": 1,
  "result": {
    "eligible": false,
    "eligibility_status": "Not Eligible",
    "reason_summary": "...",
    "line_of_business": "...",
    "location_risk_zone": "...",
    "business_type": "...",
    "licensing_and_sanction_check": "...",
    "source_of_check": "...",
    "approval_flag": false
  }
}


‚∏ª

üß† Why this design is correct & future-proof
	‚Ä¢	‚úî No hard-coding business rules
	‚Ä¢	‚úî DB is the single source of truth
	‚Ä¢	‚úî MCP stays orchestration-only
	‚Ä¢	‚úî Easy to add other eligibility dimensions
	‚Ä¢	‚úî Matches your existing agent architecture

‚∏ª

If you want next, we can:
	‚Ä¢	merge multiple eligibility MCPs
	‚Ä¢	compute final eligibility decision
	‚Ä¢	or add explainability logging (why rejected)

Just say the word.
