Perfect ‚Äî this time your requirement is fully precise, and you‚Äôre right to insist on correctness.
Below is a clean, merged, single-MCP solution, with no defaults, strict validation, and DB-driven eligibility.

I will give you complete code, file by file, exactly matching your architecture.

‚∏ª

‚úÖ FINAL, LOCKED BUSINESS RULE

From the SAME MCP (Licensing_&_Sanction_Checker_MCP):

Input

"is_Sanctioned": true | false

Decision logic

is_Sanctioned	Eligibility Status used
true	Not Eligible
false	Eligible
missing	‚ùå ERROR (handled & returned)

Output

From ref_eligibility_check, fetch the row matching eligibility status and return:
	‚Ä¢	Reason Summary
	‚Ä¢	Line of Business
	‚Ä¢	Location Risk Zone
	‚Ä¢	Business Type
	‚Ä¢	Licensing and Sanction Check
	‚Ä¢	Source of Check
	‚Ä¢	Approval Flag

üö´ No defaults
üö´ No inserts / updates
‚úÖ Only SELECT
‚úÖ Same MCP
‚úÖ Same router

‚∏ª

1Ô∏è‚É£ models.py (table mapping)

from sqlmodel import SQLModel, Field
from sqlalchemy import Column, String, Boolean
from typing import Optional


class RefEligibilityCheck(SQLModel, table=True):
    __tablename__ = "ref_eligibility_check"

    id: Optional[int] = Field(default=None, primary_key=True)

    eligibility_status: str = Field(
        sa_column=Column("Eligibility Status", String, quote=True)
    )

    reason_summary: Optional[str] = Field(
        sa_column=Column("Reason Summary", String, quote=True)
    )

    line_of_business: Optional[str] = Field(
        sa_column=Column("Line of Business", String, quote=True)
    )

    location_risk_zone: Optional[str] = Field(
        sa_column=Column("Location Risk Zone", String, quote=True)
    )

    business_type: Optional[str] = Field(
        sa_column=Column("Business Type", String, quote=True)
    )

    licensing_and_sanction_check: Optional[str] = Field(
        sa_column=Column("Licensing and Sanction Check", String, quote=True)
    )

    source_of_check: Optional[str] = Field(
        sa_column=Column("Source of Check", String, quote=True)
    )

    approval_flag: Optional[bool] = Field(
        sa_column=Column("Approval Flag", Boolean, quote=True)
    )


‚∏ª

2Ô∏è‚É£ db.py (PostgreSQL connection)

import os
from sqlmodel import create_engine
from sqlalchemy.pool import NullPool
from dotenv import load_dotenv

load_dotenv()


def get_engine():
    return create_engine(
        f"postgresql+psycopg://{os.getenv('PGUSER')}:{os.getenv('PGPASSWORD')}"
        f"@{os.getenv('PGHOST')}:{os.getenv('PGPORT', '5432')}/{os.getenv('PGDATABASE')}",
        poolclass=NullPool,
        echo=False
    )


‚∏ª

3Ô∏è‚É£ handler.py (ALL logic lives here)

from sqlmodel import Session, select
from models import RefEligibilityCheck
from db import get_engine


def process_sanction_and_eligibility(mcp_result: dict) -> dict:
    """
    - Extract is_Sanctioned (NO DEFAULTS)
    - Decide eligibility status
    - Fetch corresponding row from ref_eligibility_check
    - Return column values
    """

    # ---------- VALIDATION ----------
    if not isinstance(mcp_result, dict):
        return {
            "status": False,
            "error": "Invalid MCP result format (expected dict)"
        }

    results = mcp_result.get("results")
    if not isinstance(results, list) or not results:
        return {
            "status": False,
            "error": "'results' missing or empty in MCP response"
        }

    record = results[0]

    if "is_Sanctioned" not in record:
        return {
            "status": False,
            "error": "'is_Sanctioned' field missing in MCP response"
        }

    is_sanctioned = record["is_Sanctioned"]

    if not isinstance(is_sanctioned, bool):
        return {
            "status": False,
            "error": "'is_Sanctioned' must be boolean"
        }

    # ---------- DECISION ----------
    eligibility_status = "Not Eligible" if is_sanctioned else "Eligible"

    # ---------- DB FETCH ----------
    engine = get_engine()
    with Session(engine) as session:
        stmt = select(RefEligibilityCheck).where(
            RefEligibilityCheck.eligibility_status == eligibility_status
        )
        row = session.exec(stmt).first()

        if not row:
            return {
                "status": False,
                "error": f"No row found for Eligibility Status = '{eligibility_status}'"
            }

        # ---------- RESPONSE ----------
        return {
            "status": True,
            "eligibility_status": row.eligibility_status,
            "reason_summary": row.reason_summary,
            "line_of_business": row.line_of_business,
            "location_risk_zone": row.location_risk_zone,
            "business_type": row.business_type,
            "licensing_and_sanction_check": row.licensing_and_sanction_check,
            "source_of_check": row.source_of_check,
            "approval_flag": row.approval_flag
        }

üìå Important:
There is NO fallback, NO default, NO silent behavior.

‚∏ª

4Ô∏è‚É£ router.py (SAME MCP, extended logic)

from fastapi import APIRouter
from fastapi.responses import JSONResponse
from pydantic import BaseModel
from handler import process_sanction_and_eligibility

router = APIRouter()


class LicensingSanctionMCPRequest(BaseModel):
    jsonrpc: str
    id: int
    result: dict


@router.post(
    "/Licensing_&_Sanction_Checker_MCP",
    operation_id="Licensing_&_Sanction_Checker_MCP"
)
async def licensing_sanction_checker_mcp(request: LicensingSanctionMCPRequest):

    decision = process_sanction_and_eligibility(request.result)

    return JSONResponse(
        content={
            "jsonrpc": request.jsonrpc,
            "id": request.id,
            "result": decision
        },
        status_code=200
    )


‚∏ª

5Ô∏è‚É£ main.py (UNCHANGED ‚Äì already correct)

Use the same main.py you already have that exposes:

include_operations=["Licensing_&_Sanction_Checker_MCP"]

No changes needed.

‚∏ª

6Ô∏è‚É£ test_script.py (your exact style)

import requests
import json

BASE_URL = "http://localhost:8601/api/v1/eligibility_agent/Licensing_&_Sanction_Checker_MCP"


def run_test():
    payload = {
        "jsonrpc": "2.0",
        "id": 1,
        "result": {
            "status": True,
            "results": [
                {
                    "Extracted Name": "Berkshire Hathaway",
                    "is_Sanctioned": False
                }
            ]
        }
    }

    try:
        resp = requests.post(BASE_URL, json=payload, timeout=120)
        print("HTTP Status:", resp.status_code)

        try:
            print(json.dumps(resp.json(), indent=4))
        except Exception:
            print("Response not JSON:", resp.text)

    except Exception as e:
        print("Error calling API:", str(e))


if __name__ == "__main__":
    print("Testing Licensing & Sanction Checker MCP...")
    run_test()


‚∏ª

‚úÖ Example Outputs

‚úÖ is_Sanctioned = false

{
  "status": true,
  "eligibility_status": "Eligible",
  "reason_summary": "...",
  "line_of_business": "...",
  "location_risk_zone": "...",
  "business_type": "...",
  "licensing_and_sanction_check": "...",
  "source_of_check": "...",
  "approval_flag": true
}

‚ùå is_Sanctioned = true

{
  "status": true,
  "eligibility_status": "Not Eligible",
  "reason_summary": "...",
  "line_of_business": "...",
  "location_risk_zone": "...",
  "business_type": "...",
  "licensing_and_sanction_check": "...",
  "source_of_check": "...",
  "approval_flag": false
}

‚ùå Missing is_Sanctioned

{
  "status": false,
  "error": "'is_Sanctioned' field missing in MCP response"
}


‚∏ª

üß† Why this is the correct final design
	‚Ä¢	Single MCP = single capability
	‚Ä¢	DB = source of truth for eligibility meaning
	‚Ä¢	No silent assumptions
	‚Ä¢	Strong validation
	‚Ä¢	Matches your existing OmniCore + MCP architecture

You were right to push for this clarity ‚Äî this is production-grade eligibility logic.

If you want next:
	‚Ä¢	combine multiple eligibility checks
	‚Ä¢	add audit logging
	‚Ä¢	or build final underwriting decision MCP
