Excellent, thanks for sharing the full reference.
Iâ€™ll now do this properly and consistently with your existing PostgreSQL + MCP pattern.

You want to:
	â€¢	Connect to PostgreSQL
	â€¢	Access table ref_eligibility_check
	â€¢	Read / update column Licensing and Sanction Check
	â€¢	Use the output of your Licensing & Sanction Checker MCP
(is_Sanctioned: true | false)
	â€¢	Follow the same architectural style as:
	â€¢	models.py
	â€¢	writer.py
	â€¢	router.py
	â€¢	test_script.py

No shortcuts. No redesign.

â¸»

1ï¸âƒ£ Assumption (explicit & important)

PostgreSQL column names with spaces must be quoted.
So this column:

"Licensing and Sanction Check"

Iâ€™ll map it safely using SQLAlchemy Column(..., quote=True).

If later you rename it to licensing_and_sanction_check, everything becomes easier â€” but Iâ€™ll respect the current schema.

â¸»

2ï¸âƒ£ models.py (NEW â€“ eligibility model)

ğŸ“ models.py

from sqlmodel import SQLModel, Field
from sqlalchemy import Column, Boolean
from typing import Optional


class RefEligibilityCheck(SQLModel, table=True):
    """
    SQLModel for ref_eligibility_check table
    """

    __tablename__ = "ref_eligibility_check"

    id: Optional[int] = Field(default=None, primary_key=True)

    reference_number: str = Field(
        ..., description="Reference number linking to submission"
    )

    # Column name has spaces â†’ must be quoted
    licensing_and_sanction_check: Optional[bool] = Field(
        default=None,
        sa_column=Column(
            "Licensing and Sanction Check",
            Boolean,
            quote=True
        ),
        description="Result of licensing & sanction check"
    )

âœ” Maps exactly to PostgreSQL
âœ” Handles spaced column name
âœ” Boolean storage

â¸»

3ï¸âƒ£ writer.py (WRITE sanction result)

ğŸ“ writer.py

import os
from sqlmodel import Session, create_engine, select
from sqlalchemy.pool import NullPool
from dotenv import load_dotenv
from models import RefEligibilityCheck

load_dotenv()


def _get_postgres_connection_string() -> str:
    pghost = os.getenv("PGHOST")
    pguser = os.getenv("PGUSER")
    pgport = os.getenv("PGPORT", "5432")
    pgdatabase = os.getenv("PGDATABASE", "postgres")
    pgpassword = os.getenv("PGPASSWORD")

    if not all([pghost, pguser, pgpassword]):
        raise RuntimeError("PostgreSQL connection configuration missing")

    return f"postgresql+psycopg://{pguser}:{pgpassword}@{pghost}:{pgport}/{pgdatabase}"


def _get_postgres_engine():
    return create_engine(
        _get_postgres_connection_string(),
        echo=False,
        poolclass=NullPool
    )


def write_licensing_sanction_result(
    reference_number: str,
    is_sanctioned: bool
) -> dict:
    """
    Writes Licensing & Sanction result to ref_eligibility_check table
    """
    try:
        engine = _get_postgres_engine()

        record = RefEligibilityCheck(
            reference_number=reference_number,
            licensing_and_sanction_check=not is_sanctioned
        )

        with Session(engine) as session:
            session.add(record)
            session.commit()
            session.refresh(record)

        return {
            "is_written": True,
            "record_id": record.id,
            "reference_number": reference_number,
            "licensing_and_sanction_check": record.licensing_and_sanction_check
        }

    except Exception as e:
        return {
            "is_written": False,
            "error": str(e),
            "reference_number": reference_number
        }

ğŸ”‘ Important business logic note

I assumed:

licensing_and_sanction_check = NOT is_sanctioned

Meaning:
	â€¢	is_Sanctioned = True â†’ âŒ eligibility fails
	â€¢	is_Sanctioned = False â†’ âœ… eligibility passes

If you want direct mapping instead, tell me and Iâ€™ll flip it.

â¸»

4ï¸âƒ£ router.py (MCP entry point)

ğŸ“ router.py

from fastapi import APIRouter
from fastapi.responses import JSONResponse
from pydantic import BaseModel, Field
from writer import write_licensing_sanction_result

router = APIRouter()


class LicensingSanctionMCPRequest(BaseModel):
    reference_number: str = Field(..., description="Submission reference number")
    is_Sanctioned: bool = Field(..., description="Sanction result from MCP")


@router.post(
    "/write_licensing_sanction_result",
    operation_id="write_licensing_sanction_result"
)
async def write_licensing_sanction_result_endpoint(
    request: LicensingSanctionMCPRequest
):
    result = write_licensing_sanction_result(
        reference_number=request.reference_number,
        is_sanctioned=request.is_Sanctioned
    )

    return JSONResponse(
        content={
            "jsonrpc": "2.0",
            "id": 1,
            "result": result
        }
    )

âœ” Same pattern as your submission intake MCP
âœ” Clean MCP boundary
âœ” No DB logic in router

â¸»

5ï¸âƒ£ test_script.py (CLIENT test â€“ matches your style)

ğŸ“ test_script.py

import requests
import json

BASE_URL = "http://localhost:8601/api/v1/eligibility_agent/write_licensing_sanction_result"

def run_test():
    payload = {
        "reference_number": "REF-2026-001",
        "is_Sanctioned": False
    }

    try:
        resp = requests.post(BASE_URL, json=payload, timeout=180)
        print("HTTP Status:", resp.status_code)

        try:
            data = resp.json()
            print(json.dumps(data, indent=4))
        except Exception:
            print("Response not JSON:", resp.text)

    except Exception as e:
        print("Error calling API:", str(e))


if __name__ == "__main__":
    print("Testing write_licensing_sanction_result MCP ...")
    run_test()


â¸»

6ï¸âƒ£ End-to-end flow (now complete)

Licensing & Sanction MCP
        â†“
is_Sanctioned = false
        â†“
Router
        â†“
writer.py
        â†“
ref_eligibility_check
"Licensing and Sanction Check" = TRUE


â¸»

7ï¸âƒ£ Why this fits your architecture perfectly

âœ… Same SQLModel usage
âœ… Same writer / router separation
âœ… Same MCP JSON-RPC envelope
âœ… Same test script style
âœ… Safe handling of spaced column names
âœ… Ready to plug into OmniCore eligibility flow

â¸»

Next logical step (only if you say so)
	â€¢	Update instead of insert (UPSERT by reference_number)
	â€¢	Join with agent_submission_intake
	â€¢	Drive final eligibility decision MCP

Youâ€™re building this exactly the right way.
