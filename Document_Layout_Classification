guidewireclient.py

import requests

BASE_URL = "https://pc-sandbox-gwcpdev.hexaware.zeta1-andromeda.guidewire.net/rest"

HEADERS = {
    "Content-Type": "application/json",
    "accept": "application/json",
    "authorization": "Basic c3U6Z3c="
}

def post(uri: str, body: dict):
    response = requests.post(BASE_URL + uri, json=body, headers=HEADERS)
    response.raise_for_status()
    return response.json()


document_mapper.py



from datetime import datetime
from models.model_data import QuoteData
from State_Abbrevation.us_state_abbrevation import us_states_abbreviations


def get_value_anywhere(data, target_key):
    """
    Find a key anywhere in nested dict/list JSON.
    Returns first match or None.
    """
    if isinstance(data, dict):
        for key, value in data.items():
            if key == target_key:
                return value
            found = get_value_anywhere(value, target_key)
            if found is not None:
                return found

    elif isinstance(data, list):
        for item in data:
            found = get_value_anywhere(item, target_key)
            if found is not None:
                return found

    return None


def map_document_to_model_data(doc: dict) -> QuoteData:
    # Get values from anywhere in JSON
    company_name = get_value_anywhere(doc, "Named Insured (Company Name)")
    organization_type = get_value_anywhere(doc, "Organization Type")

    address_line1 = get_value_anywhere(doc, "Address Line 1")
    city = get_value_anywhere(doc, "City")
    full_state_name = get_value_anywhere(doc, "State")
    postal_code = get_value_anywhere(doc, "Zip Code")

    date_str = get_value_anywhere(doc, "Effective Date")

    # Convert the date string to desired format, with error handling
    if date_str:
        try:
            date_obj = datetime.strptime(date_str, "%d/%m/%Y")
            job_effective_date = date_obj.strftime("%Y-%m-%d")
        except ValueError:
            job_effective_date = None
    else:
        job_effective_date = None

    # Lookup state abbreviation
    state_abbreviation = us_states_abbreviations.get(
        full_state_name, full_state_name
    )

    return QuoteData(
        company_name=company_name,
        organization_type=organization_type,

        address_line1=address_line1,
        city=city,
        state=state_abbreviation,
        postal_code=postal_code,

        # Fixed producer code as per business rule
        producer_code="pc:6",

        job_effective_date=job_effective_date
    )


model_data.py

from dataclasses import dataclass
@dataclass
class QuoteData:
    company_name:str
    organization_type:str

    address_line1:str
    city: str
    state: str
    postal_code: str

    producer_code : str
    job_effective_date: str


account_payload.py
from models.model_data import QuoteData
from State_Abbrevation import us_state_abbrevation

def build_account_payload(data: QuoteData) -> dict:
    return {
        "data": {
            "attributes": {
                "initialAccountHolder": {
                    "contactSubtype": "Company",
                    "companyName": data.company_name,
                    "primaryAddress": {
                        "addressLine1": data.address_line1,
                        "city": data.city,
                        "postalCode": data.postal_code,
                        "state": {
                            "code": data.state[:2].upper()
                        }
                    }
                },
                "initialPrimaryLocation": {
                    "addressLine1": data.address_line1,
                    "city": data.city,
                    "postalCode": data.postal_code,
                    "state": {
                        "code": data.state[:2].upper()
                        }
                },
                "producerCodes": [
                    {"id": "pc:6"}
                ],
                "organizationType": {
                    "code": data.organization_type
                }
            }
        }
    }


coverage_payload.py
def get_coverages():
    return [
        {
            "clauseType": "coverage",
            "id": "GCPPropertyOffPrem",
            "pattern": {"id": "GCPPropertyOffPrem"},
            "terms": {
                "GCPPropertyOffPremDeductible": {"directValue": "50000.00"},
                "GCPPropertyOffPremInterContinent": {"directValue": "50000.00"},
                "GCPPropertyOffPremLimit": {"directValue": "400000.00"},
                "GCPPropertyOffPremWithinTerrLimit": {"directValue": "25000.00"}
            }
        }
]

job_payload.py
from models.model_data import QuoteData
from payload_builders import job_payload

def build_job_payload(account_id: str, data: QuoteData) -> dict:

    
    return {
        "data": {
            "attributes": {
                "account": {
                    "id": account_id
                },
                "baseState": {
                    "code": data.state[:2].upper()
                },
                "jobEffectiveDate": data.job_effective_date,
                "product": {
                    "id": "GoCommercialProp"
                },
                "producerCode": {
                    "id": "pc:6"
                }
            }
        }
    }


location_payload.py
from models.model_data import QuoteData

def build_location_payload(data: QuoteData) -> dict:
    return {
        "data": {
            "attributes": {
                "addressLine1": data.address_line1,
                "city": data.city,
                "postalCode": data.postal_code,
                "state": {
                    "code": data.state[:2].upper()
                },
                "coverableJurisdiction": {
                    "code": data.state[:2].upper(),
                    # "name": data.state
                }
            }
        }
    }


handler.py







# handler.py
from typing import Dict, Any
from service import _require_env
from storage_utils import read_json_from_blob
from mappers.document_mapper import map_document_to_model_data
from payload_builders.account_payload import build_account_payload
from payload_builders.job_payload import build_job_payload
from payload_builders.location_payload import build_location_payload
from payload_builders.coverage_payloads import get_coverages
from clients.guidewire_client import post
from service import _ref_parse_blob_url
from storage_utils import save_json_output_to_blob

async def guidewire_api_call(blob_url: str) -> Dict[str, Any]:
    """
    Reads JSON directly from Azure Blob and calls Guidewire APIs to get the Quote.
    """
    try:
        _require_env()
    except Exception as e:
        return {"status": False, "error": f"Environment misconfigured: {e}"}

    try:
        document = await read_json_from_blob(blob_url)
        print(document)
    except Exception as e:
        return {"status": False, "error": f"Failed to read blob: {e}"}
    
    try:
        canonical = map_document_to_model_data(document)
        print("Canonical",canonical)
    except Exception as e:
        return {"status": False, "error": f"Failed to map data : {e}"}

        # canonical = map_document_to_canonical(document)
    account_resp = post("/account/v1/accounts", build_account_payload(canonical))
    account_id = account_resp["data"]["attributes"]["id"]
    
    print("account_id",account_id)

    job_resp = post("/job/v1/submissions", build_job_payload(account_id, canonical))
    job_id = job_resp["data"]["attributes"]["id"]

    print("JOB ID :",job_id)
    location_resp = post(
        f"/job/v1/jobs/{job_id}/lines/GOCommercialLine/locations",
        build_location_payload(canonical)
    )
    location_id = location_resp["data"]["attributes"]["id"]

    for coverage in get_coverages():
        post(
            f"/job/v1/jobs/{job_id}/lines/GOCommercialLine/coverages",
            {"data": {"attributes": coverage}}
        )

    quote_resp = post(f"/job/v1/jobs/{job_id}/quote", {})

    try:
        container, blob_path, ref_id, name = _ref_parse_blob_url(blob_url)
        print("Container:", container)
        print("Blob_path:", blob_path)
        print("Ref_id:", ref_id)
        print("Name:", name)
    except Exception as e:
        return {"status": False, "error": f"Failed to extract name from blob url : {e}"}
    
    try:
        await save_json_output_to_blob(ref_id,name,quote_resp)
    except Exception as e:
        return {"status": False, "error": f"Failed to extract name from blob url : {e}"} 


    return {
        "status": True,
        # "accountId": account_id,
        # "jobId": job_id,
        # "locationId": location_id,
        "quote": quote_resp
    }


main.py


from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from fastapi_mcp import FastApiMCP
import uvicorn

from router import router as file_router


def apply_cors(app: FastAPI):
    app.add_middleware(
        CORSMiddleware,
        allow_origins=["*"],
        allow_methods=["*"],
        allow_headers=["*"],
    )


def create_sub_app(title: str, description: str, version: str = "0.1.0") -> FastAPI:
    sub = FastAPI(title=title, description=description, version=version)
    apply_cors(sub)
    return sub


app = FastAPI()
apply_cors(app)

file_app = create_sub_app(
    title="Guidewire Quote Integration",
    description="Exposes an API to generate commercial property insurance quotes in "
       "Guidewire PolicyCenter using structured submission data stored in "
       "Azure Blob Storage. The service reads JSON submission documents, "
       "maps them to Guidewire domain models, and orchestrates account, job, "
       "location, coverage creation, and quote generation."
)
file_app.include_router(file_router)

# Expose ONLY this operation id via MCP HTTP (client will use transport='http')
FastApiMCP(file_app, include_operations=["Guidewire_Quote"]).mount_http()

# Mount the sub-app under this prefix (keep as-is per your request)
# app.mount("/api/v1/eligibility_agent", file_app)
app.mount("/api/v1/quote", file_app)


if __name__ == "__main__":
    uvicorn.run(app, host="0.0.0.0", port=8601)


router.py

from fastapi import APIRouter
from fastapi.responses import JSONResponse
from pydantic import BaseModel, Field
from handler import guidewire_api_call

router = APIRouter()

class QuoteRequest(BaseModel):
    attachment_url: str = Field(..., description="Full Azure Blob URL pointing to a JSON document that contains "
           "extracted insurance submission data required for quote generation.")

@router.post("/Guidewire_Quote", operation_id="Guidewire_Quote",
             summary="Generate a commercial property quote in Guidewire using submission data from Azure Blob")
async def generate_quote(request: QuoteRequest):
    """
    Reads a structured JSON submission document directly from Azure Blob Storage.

    Only Azure Blob URLs containing "_Submission_Document_" in the blob name
    (e.g., "..._Submission_Document_...json") will be considered valid for processing.

    This service invokes Guidewire PolicyCenter APIs to generate a commercial property quote.
    The JSON document is expected to already contain extracted and structured data
    (for example, insured details, property location, producer information, and
    policy effective dates). This service does NOT perform document parsing,
    OCR, or layout analysis.

    Flow:
    1. Read JSON content directly from Azure Blob (in-memory).
    2. Map submission data to an internal data model.
    3. Create Account, Job, Location, and Coverages in Guidewire.
    4. Trigger quote generation and return the result.

    Args:
        request (QuoteRequest):
            - attachment_url: Azure Blob URL of the JSON submission document.

    Returns:
        JSONResponse:
            JSON-RPC style response containing the generated quote details,
            or an error message if the process fails.
    """
    try:
        result = await guidewire_api_call(request.attachment_url)
        return JSONResponse(content={"jsonrpc": "2.0", "id": 1, "result": result}, status_code=200)
    except Exception as e:
        return JSONResponse(content={"jsonrpc": "2.0", "id": 1,
                                     "result": {"status": False, "error": str(e)}}, status_code=200)


service.py


import os
from urllib.parse import urlparse, unquote
from dotenv import load_dotenv

load_dotenv()

AZURE_STORAGE_CONNECTION_STRING = os.environ.get("AZURE_STORAGE_CONNECTION_STRING", "")

def _require_env() -> None:
    """Ensure required environment variables exist."""
    if not AZURE_STORAGE_CONNECTION_STRING:
        raise RuntimeError("Missing AZURE_STORAGE_CONNECTION_STRING in environment/.env")

def _extract_ref_id_and_name(blob_path: str) -> tuple[str, str]:
    """
    Extract ref_id and name from blob_path.
    Example blob_path:
      19C1DD3DD82FAE03_attachment_SunflowerHotels_Submission_Document_extraction_20260202_101302.json
    Returns:
      ref_id = "19C1DD3DD82FAE03"
      name = "SunflowerHotels_Submission_Document_extraction_20260202_101302.json"
    """
    parts = blob_path.split('_attachment_', 1)
    if len(parts) != 2:
        raise ValueError("blob_path format unexpected, missing '_attachment_' separator")
    ref_id = parts[0]
    name = parts[1]
    return ref_id, name

def _ref_parse_blob_url(url: str) -> tuple[str, str, str, str]:
    """
    Parse an Azure Blob URL and return (container_name, blob_path, ref_id, name).
    Example URL:
      https://account.blob.core.windows.net/output-results/19C1DD3DD82FAE03_attachment_SunflowerHotels_Submission_Document_extraction_20260202_101302.json
    Returns:
      ("output-results", "19C1DD3DD82FAE03_attachment_SunflowerHotels_Submission_Document_extraction_20260202_101302.json",
       "19C1DD3DD82FAE03", "SunflowerHotels_Submission_Document_extraction_20260202_101302.json")
    """
    parsed = urlparse(url)
    if not parsed.scheme.startswith("http"):
        raise ValueError("url must be a valid http(s) Azure Blob URL.")

    path = parsed.path.lstrip("/")
    if "/" not in path:
        raise ValueError("url must include both container and blob path.")
    parts = path.split("/", 1)
    container = parts[0]
    blob_path = parts[1]
    ref_id, name = _extract_ref_id_and_name(unquote(blob_path))
    return unquote(container), blob_path, ref_id, name


def _parse_blob_url(url: str) -> tuple[str, str]:
    """
    Parse an Azure Blob URL and return (container_name, blob_path).
    Example URL:
      https://account.blob.core.windows.net/output-results/folder/name.pdf
    Returns:
      ("output-results", "folder/name.pdf")
    """
    parsed = urlparse(url)
    if not parsed.scheme.startswith("http"):
        raise ValueError("url must be a valid http(s) Azure Blob URL.")

    path = parsed.path.lstrip("/")
    if "/" not in path:
        raise ValueError("url must include both container and blob path.")
    parts = path.split("/", 1)
    container = parts[0]
    blob_path = parts[1]
    return unquote(container), unquote(blob_path)

storage_utils.py


# storage_utils.py
import json
import os
from azure.storage.blob.aio import BlobServiceClient
from azure.core.exceptions import ResourceNotFoundError
from service import AZURE_STORAGE_CONNECTION_STRING, _parse_blob_url


async def read_json_from_blob(blob_url: str) -> dict:
    """
    Reads a JSON file directly from Azure Blob Storage and returns it as dict.
    No local file system usage.
    """
    if not AZURE_STORAGE_CONNECTION_STRING:
        raise RuntimeError("AZURE_STORAGE_CONNECTION_STRING not set")

#working code
    container, blob_path = _parse_blob_url(blob_url)
    print("Container", container)
    print("Blob_path", blob_path)

    # container, blob_path, ref_id, name = _parse_blob_url(blob_url)
    # print("Container:", container)
    # print("Blob_path:", blob_path)
    # print("Ref_id:", ref_id)
    # print("Name:", name)

    async with BlobServiceClient.from_connection_string(
        AZURE_STORAGE_CONNECTION_STRING
    ) as service:
        container_client = service.get_container_client(container)
        blob_client = container_client.get_blob_client(blob_path)

        try:
            await blob_client.get_blob_properties()
        except ResourceNotFoundError:
            raise FileNotFoundError(
                f"Blob not found: container={container}, blob={blob_path}"
            )

        stream = await blob_client.download_blob()
        raw_bytes = await stream.readall()

    return json.loads(raw_bytes.decode("utf-8"))




GUIDEWIRE_QUOTE_CONTAINER = os.environ.get("GUIDEWIRE_QUOTE_CONTAINER")

async def save_json_output_to_blob(ref_id: str, name: str, quote_resp: dict):
    """
    Save quote_resp JSON to Azure Blob Storage in the container specified by GUIDEWIRE_QUOTE_CONTAINER,
    with blob name formatted as "{ref_id}_Quote_{name}".
    """
    if not AZURE_STORAGE_CONNECTION_STRING:
        raise RuntimeError("AZURE_STORAGE_CONNECTION_STRING not set")

    blob_name = f"{ref_id}_Quote_{name}"

    # Serialize quote_resp dict to JSON string
    json_data = json.dumps(quote_resp, indent=2)

    async with BlobServiceClient.from_connection_string(
        AZURE_STORAGE_CONNECTION_STRING
    ) as service:
        container_client = service.get_container_client(GUIDEWIRE_QUOTE_CONTAINER)

        # Create container if not exists (optional)
        try:
            await container_client.get_container_properties()
        except Exception:
            await container_client.create_container()

        blob_client = container_client.get_blob_client(blob_name)

        # Upload JSON string as bytes
        await blob_client.upload_blob(json_data.encode("utf-8"), overwrite=True)






