You’re right — your newsummary.summarize_attachments and the handler calls were inconsistent (undefined names, different expectations). I fixed that and gave you one clear, working change set you can drop in.

What I changed for you (copy/paste):
	•	newsummary.py — made extract_refs_from_attachments accept both kinds of inputs (items with file_name or reference_number) and made summarize_attachments accept an optional email_bodies dict (so you can pass the files you downloaded). Removed the undefined names and made the function self-contained and safe.
	•	summary_handler.py — showed the exact spot and the exact small snippet to call the ref-extractor, load the local email bodies map, and then call summarize_attachments(..., email_bodies=...).

Drop these into your repo.

⸻

1) Replace newsummary.py with this (or patch the functions shown)

# newsummary.py (replace/patch relevant parts)
from dotenv import load_dotenv
import os
from typing import List, Dict, Optional
from openai import AzureOpenAI

load_dotenv()

AZURE_OPENAI_ENDPOINT = os.getenv("AZURE_OPENAI_ENDPOINT")
AZURE_OPENAI_API_VERSION = os.getenv("AZURE_OPENAI_API_VERSION")
AZURE_OPENAI_API_KEY = os.getenv("AZURE_OPENAI_API_KEY")
AZURE_OPENAI_CHAT_DEPLOYMENT = os.getenv("AZURE_OPENAI_CHAT_DEPLOYMENT")

if not (
    AZURE_OPENAI_ENDPOINT
    and AZURE_OPENAI_API_VERSION
    and AZURE_OPENAI_API_KEY
    and AZURE_OPENAI_CHAT_DEPLOYMENT
):
    raise RuntimeError("Azure OpenAI env vars missing.")

client = AzureOpenAI(
    api_key=AZURE_OPENAI_API_KEY,
    api_version=AZURE_OPENAI_API_VERSION,
    azure_endpoint=AZURE_OPENAI_ENDPOINT,
)


def extract_refs_from_attachments(attachments: List[Dict]) -> List[str]:
    """
    Return unique refs. Accept items that either:
      - have 'file_name' like '<REF>_...' OR
      - have 'reference_number' key directly (from beautify_data)
    """
    refs = []
    for item in attachments or []:
        # priority: explicit reference_number if present
        ref_direct = item.get("reference_number") or item.get("reference")
        if ref_direct:
            refs.append(str(ref_direct))
            continue

        fname = item.get("file_name", "") or ""
        if "_" in fname:
            refs.append(fname.split("_", 1)[0])

    # unique while preserving order
    seen = set()
    out = []
    for r in refs:
        if r not in seen:
            seen.add(r)
            out.append(r)
    return out


def load_raw_email_bodies_for_refs(refs: List[str], email_body_folder: str = "email_body") -> Dict[str, Dict]:
    """
    Load local files named `body_<ref>.txt` from email_body_folder.
    Returns dict: ref -> {"status": "ok", "path": ..., "raw": "<full text>"} or {"status":"missing"/"error"}.
    """
    base = os.path.dirname(os.path.abspath(__file__))
    out: Dict[str, Dict] = {}
    for ref in refs or []:
        fname = f"body_{ref}.txt"
        path = os.path.join(base, email_body_folder, fname)
        if not os.path.exists(path):
            out[ref] = {"status": "missing", "path": path}
            continue
        try:
            with open(path, "r", encoding="utf-8", errors="ignore") as f:
                raw = f.read()
            out[ref] = {"status": "ok", "path": path, "raw": raw}
        except Exception as e:
            out[ref] = {"status": "error", "path": path, "error": str(e)}
    return out


def summarize_attachments(
    attachments: List[Dict],
    email_bodies: Optional[Dict[str, Dict]] = None,
    include_email_bodies_in_prompt: bool = True,
) -> str:
    """
    Build combined submission summary.

    - attachments: list of {"file_name":..., "summary":..., "text":...} OR items with 'reference_number'.
    - email_bodies: optional dict mapping ref -> {"status":"ok","raw": "..."} (if None, function will try to load local files).
    - include_email_bodies_in_prompt: if False, email bodies will not be included even if available.

    Returns the LLM string result.
    """
    # build attachments text (short summaries)
    attachment_chunks = []
    for item in attachments or []:
        file_name = item.get("file_name", "unknown_file")
        summary_text = item.get("summary", "") or ""
        chunk = f"FILENAME: {file_name}\nSUMMARY: {summary_text}"
        attachment_chunks.append(chunk)
    attachments_text = "\n\n".join(attachment_chunks)
    attachments_text = attachments_text[:8000]  # safety

    # ensure we have email_bodies map (if caller didn't pass, try loading from disk)
    if email_bodies is None:
        refs = extract_refs_from_attachments(attachments)
        email_bodies = load_raw_email_bodies_for_refs(refs)
    else:
        # make a shallow defensive copy
        email_bodies = dict(email_bodies)

    # build email bodies section (keep short per ref)
    email_chunks = []
    if include_email_bodies_in_prompt and isinstance(email_bodies, dict):
        for ref, meta in email_bodies.items():
            if not meta or meta.get("status") != "ok":
                continue
            raw = meta.get("raw", "") or ""
            # instruct model to ignore salutations/signatures via prompt wording below
            snippet = raw[:3000]
            email_chunks.append(f"REFERENCE: {ref}\nRAW_EMAIL_BODY:\n{snippet}")
    email_bodies_text = "\n\n---\n\n".join(email_chunks)
    if email_bodies_text and len(email_bodies_text) > 6000:
        email_bodies_text = email_bodies_text[:6000] + "\n[TRUNCATED]"

    # final prompt: make explicit instruction to use only main body content
    prompt = f"""
You are an experienced Commercial Insurance Underwriter.

You are given multiple attachment documents that belong to a SINGLE
commercial insurance submission (file name + short summary). You MAY also have
the raw email body text(s) that accompanied the submission; if present they
are below. When using the email text, use only the main content (ignore salutations,
sign-offs, and signature contact lines). Do NOT invent facts.

Attached files (short summaries):
{attachments_text}

# RAW EMAIL BODIES (if any; use only main content, ignore salutations/signatures):
{email_bodies_text}

Produce ONE combined "Submission Summary" for the account using the following TEMPLATE (fill sections where you have data). Use only facts present in attachments or the provided email bodies.
SUBMISSION SUMMARY  
Client: [Client Legal Name]  
Date: [Submission or Document Date]

1. SUBMISSION COVER LETTER / NARRATIVE  
 Exposure Description:  
    - [Describe what the business does]  
    - [Main operations / physical activities]  
    - [Property details: construction, age, protection, sprinklers, etc.]  

 Placement Strategy:  
    - [Placement goals or program approach if evident]  

 Renewal Highlights:  
    - [Notable changes or updates if mentioned]  

 Changes YOY:  
    - [Any changes in exposure, values, operations, or loss experience]  

 Additional Overview Details:  
    - Effective Date: [Coverage start date]  
    - Submission Type: [Renewal / New Business / Other]  
    - Current Situation: [Reason for submission if stated]  

2. LOSS HISTORY PACKAGE   
 5–10 Year Loss Runs:  
    - [Summarize multi-year loss experience if available]  

 Large Loss Details:  
    - [Brief details on significant claims]  

 Trends Analysis:  
    - [Patterns in frequency/severity if evident]  

 Summary of Loss History:  
    - Status: [Clean / Losses Reported]  
    - Summary: [1-sentence overview]  
    - Major Incidents: [Largest incident if present]  

3. EXPOSURE DATA  
 COPE Information (Construction, Occupancy, Protection, Exposure):  
    - [Building info, occupancy, protection systems]  

 Statement of Values (SOV):  
    - Total Insurable Value (TIV): $[Insert if present]  
    - Building Limit: $[Insert]  
    - Contents/BPP Limit: $[Insert]  
    - Business Income: $[Insert]  

Financials, CAT worksheets, Specialty schedules, etc., as needed.

ATTACHMENT SUMMARY LIST: (file name then short summary)
{attachments_text}

# End of template.
    """

    response = client.chat.completions.create(
        model=AZURE_OPENAI_CHAT_DEPLOYMENT,
        messages=[{"role": "user", "content": prompt}],
        max_tokens=1024,
        temperature=0.2,
    )

    try:
        return response.choices[0].message.content.strip()
    except Exception:
        return getattr(response.choices[0].message, "content", "").strip()


⸻

2) Update summary_handler.py where you build combined summary

Replace the part marked #HERE WE CAN CALL THE EXTRACT REFS... with this exact snippet (it uses the filenamesummary_extracted_beautified list you already created — that contains file_name and summary and is the right thing to pass):

        # --- load local email bodies for refs and call summarize_attachments with them ---
        try:
            # use the per-doc list (each entry has file_name + summary + text)
            refs = extract_refs_from_attachments(filenamesummary_extracted_beautified)
            print("Extracted refs for email bodies:", refs)

            # load whatever body_<ref>.txt files exist under email_body/
            email_bodies_map = load_raw_email_bodies_for_refs(refs, email_body_folder=EMAIL_BODY)
            print("Loaded email bodies map:", email_bodies_map)

            # pass the email_bodies_map explicitly to the summarizer (safer & debuggable)
            combined_summary_text = summarize_attachments(
                filenamesummary_extracted_beautified,
                email_bodies=email_bodies_map,
                include_email_bodies_in_prompt=True,
            )
            print("Combined Submission Summary:")
            print(combined_summary_text)

            result["combined_summary"] = combined_summary_text
        except Exception as e:
            print(f"Error generating combined submission summary: {e}")
            result["combined_summary_error"] = str(e)
            combined_summary_text = None

Notes:
	•	I use filenamesummary_extracted_beautified (the list you get from extract_filenames_and_summaries(output_folder)) — that list contains file_name keys so extract_refs_from_attachments will pick up refs. If you prefer to pass beautify_data (which has reference_number), extract_refs_from_attachments also supports that now.
	•	email_bodies_map will look like { "19AA119...": {"status":"ok","raw":"..."} , "XYZ": {"status":"missing"} }. The summarizer reads only status == "ok" entries.

⸻

3) A couple of operational reminders (short)
	•	Make sure your download_blob_to_input_folder_by_reference actually ran before this code (you already call it earlier — good). Verify email_body/body_<ref>.txt files exist on disk (the handler prints download_results — check it).
	•	If the LLM returns empty or errors (429), log the LLM response / exception (you already print exceptions in other parts). If you get 429s often, add a small retry wrapper later.
	•	Use the filenamesummary_extracted_beautified list for both combined summary and individual_summary — keeps data consistent.

⸻

If you want I can:
	•	Give you a tiny try/except patch to separate_summary.individual_summary so per-document LLM failures don’t kill the whole list (I recommend it).
	•	Or give a 3-retry decorator for the Azure LLM calls.

Tell me which and I’ll paste it — no more fuss.
