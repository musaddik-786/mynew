document_loader.py



from dotenv import load_dotenv
import os
from azure.ai.formrecognizer import DocumentAnalysisClient
from azure.core.credentials import AzureKeyCredential

# Load environment variables from .env file
load_dotenv()

# Fetch variables
endpoint = os.getenv("LD_AZURE_FORMRECOG_ENDPOINT")
key = os.getenv("LD_AZURE_FORMRECOG_KEY")
# Fail fast if missing
if not endpoint:
    raise ValueError(" LD_AZURE_FORMRECOG_ENDPOINT is not set. Check your .env file.")
if not key:
    raise ValueError(" LD_AZURE_FORMRECOG_KEY is not set. Check your .env file.")

# Create the client using the key and endpoint
client = DocumentAnalysisClient(endpoint=endpoint, credential=AzureKeyCredential(key))

def load_document(file_path):
    """
    Extracts text and layout information using Form Recognizer's prebuilt-layout model.
    """
    with open(file_path, "rb") as f:
        poller = client.begin_analyze_document("prebuilt-layout", document=f)
        result = poller.result()

    # Debugging: Print available attributes in DocumentPage
    # print("Available attributes in DocumentPage:")
    # print(dir(result.pages[0]))
    # print("/n")
    # print("/n")

    # Extract lines of text
    lines = [line.content for page in result.pages for line in page.lines]

    # Extract table information if available
    tables = []
    for page in result.pages:
        if hasattr(page, "tables"):  # Check if 'tables' attribute exists
            for table in page.tables:
                table_data = []
                for row in table.cells:
                    table_data.append(row.content)
                tables.append(table_data)

    # Combine text and table information
    document_content = {
        "text": "n".join(lines),
        "tables": tables if tables else "No tables detected"
    }
    return document_content



file_router.py



from fastapi import APIRouter
from fastapi.responses import JSONResponse
from pydantic import BaseModel, Field
from handler import classify_blob_pdf_layout

router = APIRouter()

class LayoutDetectRequest(BaseModel):
    attachment_url: str = Field(..., description="Full Azure Blob URL to the PDF attachment.")

@router.post("/layout_detection_mcp", operation_id="layout_detection_mcp",
             summary="Download PDF from blob, analyze layout using Form Recognizer, and classify layout")
async def detect_layout(request: LayoutDetectRequest):
    try:
        result = await classify_blob_pdf_layout(request.attachment_url)
        return JSONResponse(content={"jsonrpc": "2.0", "id": 1, "result": result}, status_code=200)
    except Exception as e:
        return JSONResponse(content={"jsonrpc": "2.0", "id": 1,
                                     "result": {"status": False, "error": str(e)}}, status_code=200)


classifier.py


from dotenv import load_dotenv
import os
from openai import AzureOpenAI  # ✅ Correct import for Azure OpenAI

# Load environment variables
load_dotenv()

AZURE_OPENAI_ENDPOINT = os.getenv("AZURE_OPENAI_ENDPOINT")
AZURE_OPENAI_API_VERSION = os.getenv("AZURE_OPENAI_API_VERSION")
AZURE_OPENAI_API_KEY = os.getenv("AZURE_OPENAI_API_KEY")
AZURE_OPENAI_CHAT_DEPLOYMENT = os.getenv("AZURE_OPENAI_CHAT_DEPLOYMENT")

if not (AZURE_OPENAI_ENDPOINT and AZURE_OPENAI_API_VERSION and AZURE_OPENAI_API_KEY and AZURE_OPENAI_CHAT_DEPLOYMENT):
    raise RuntimeError("Azure OpenAI env vars missing. Please set AZURE_OPENAI_ENDPOINT, AZURE_OPENAI_API_VERSION, AZURE_OPENAI_API_KEY and AZURE_OPENAI_CHAT_DEPLOYMENT")

# ✅ Create Azure OpenAI client
client = AzureOpenAI(
    api_key=AZURE_OPENAI_API_KEY,
    api_version=AZURE_OPENAI_API_VERSION,
    azure_endpoint=AZURE_OPENAI_ENDPOINT,
)

def classify_document(document_content):
    text = document_content.get("text", "")



    prompt = f"""
You are an expert in insurance documentation and intelligent document processing.
Your task is to classify a given insurance-related document into EXACTLY ONE of the following categories:
1. ACORD
2. SOV
3. LOSS_RUN
4. NON_ACORD
Definitions:
ACORD:
A standardized insurance form published by ACORD (Association for Cooperative Operations Research and Development),
used for applications, certificates, or evidence of insurance.
These documents usually:
- Contain “ACORD” followed by a form number (e.g., ACORD 25, ACORD 27, ACORD 125, ACORD 130)
- Have structured fields such as Producer, Insured, Certificate Holder, Policy Number
- Summarize coverage or serve as an application or certificate
SOV (Schedule / Statement of Values):
A document that lists insured property values, usually in a tabular format.
These documents usually:
- Contain titles like “Schedule of Values” or “Statement of Values”
- Include location-wise or building-wise property descriptions and values
- Have columns such as Location, Building, Description, ACV, RC, 100% Values, Rates
- May reference or be labeled as ACORD 139
- Focus on property valuation, not coverage certification
LOSS_RUN:
A document that summarizes historical insurance claims.
These documents usually:
- Contain phrases like “Loss Run Report”, “Claims History”, or “Valuation Date”
- List claim numbers, dates of loss, descriptions, paid amounts, reserves, and total incurred losses
- Cover a historical time period
- Do NOT function as applications or certificates
NON_ACORD:
Any insurance-related document that is NOT an ACORD form, SOV, or Loss Run.
This includes:
- Quote documents
- Property detail reports
- Underwriting summaries
- Exposure analyses
- Proposals, narratives, internal reports, or supporting documentation
- Documents that reference ACORD forms but are not themselves ACORD forms
Document Content:
{text[:2000]}
Reply with ONLY ONE word from the following options:
ACORD
SOV
LOSS_RUN
NON_ACORD
"""



    response = client.chat.completions.create(
        model=AZURE_OPENAI_CHAT_DEPLOYMENT,
        messages=[{"role": "user", "content": prompt}],
        max_tokens=4,
        temperature=0.0
    )

    try:
        return response.choices[0].message.content.strip()
    except Exception:
        return getattr(response.choices[0].message, "content", "").strip()



handler.py

import os
import json
from typing import Dict, Any
from service import _require_env
from storage_utils import download_blob_to_input_folder
from document_loader import load_document
from classifier import classify_document

INPUT_FOLDER = "input"
OUTPUT_FOLDER = "output"

async def classify_blob_pdf_layout(blob_url: str) -> Dict[str, Any]:
    """
    - Download PDF into input/
    - Use Form Recognizer to analyze layout
    - Classify layout using extracted content
    - Return minimal verdict
    """
    try:
        _require_env()
    except Exception as e:
        return {"status": False, "error": f"Environment misconfigured: {e}"}

    # 1) Download PDF
    try:
        local_pdf = await download_blob_to_input_folder(blob_url, input_folder=INPUT_FOLDER)
    except Exception as e:
        return {"status": False, "error": f"Failed to download blob: {e}"}

    # 2) Use Form Recognizer to analyze the document
    try:
        document_content = load_document(local_pdf)
    except Exception as e:
        return {"status": False, "error": f"Form Recognizer failed: {e}"}

    # 3) Classify layout using extracted content
    try:
        layout_type = classify_document(document_content)
    except Exception as e:
        return {"status": False, "error": f"Classification failed: {e}"}

    result = {"status": True, "layout_type": layout_type, "details": document_content}

    # 4) Save minimal output to ./output
    try:
        os.makedirs(OUTPUT_FOLDER, exist_ok=True)
        out_path = os.path.join(OUTPUT_FOLDER, "layout_classification_result.json")
        with open(out_path, "w", encoding="utf-8") as f:
            json.dump(result, f, indent=2, ensure_ascii=False)
    except Exception as e:
        result["save_error"] = str(e)

    return result



serivce.py

# service.py
#Working code 

import os
from urllib.parse import urlparse, unquote
from dotenv import load_dotenv

load_dotenv()

AZURE_STORAGE_CONNECTION_STRING = os.environ.get("AZURE_STORAGE_CONNECTION_STRING", "")

def _require_env() -> None:
    """Ensure required environment variables exist."""
    if not AZURE_STORAGE_CONNECTION_STRING:
        raise RuntimeError("Missing AZURE_STORAGE_CONNECTION_STRING in environment/.env")

def _parse_blob_url(url: str) -> tuple[str, str]:
    """
    Parse an Azure Blob URL and return (container_name, blob_path).
    Example URL:
      https://account.blob.core.windows.net/output-results/folder/name.pdf
    Returns:
      ("output-results", "folder/name.pdf")
    """
    parsed = urlparse(url)
    if not parsed.scheme.startswith("http"):
        raise ValueError("url must be a valid http(s) Azure Blob URL.")

    path = parsed.path.lstrip("/")
    if "/" not in path:
        raise ValueError("url must include both container and blob path.")
    parts = path.split("/", 1)
    container = parts[0]
    blob_path = parts[1]
    return unquote(container), unquote(blob_path)

storage_utils.py

#Working code 
# storage_utils.py
import os
import aiofiles
from azure.storage.blob.aio import BlobServiceClient
from azure.core.exceptions import ResourceNotFoundError
from service import AZURE_STORAGE_CONNECTION_STRING, _parse_blob_url

async def download_blob_to_input_folder(blob_url: str, input_folder: str = "input") -> str:
    """
    Downloads the blob at blob_url into input_folder (root-level) preserving filename.
    Returns the local path to the downloaded file.
    """
    if not AZURE_STORAGE_CONNECTION_STRING:
        raise RuntimeError("AZURE_STORAGE_CONNECTION_STRING not set")

    container, blob_path = _parse_blob_url(blob_url)
    filename = os.path.basename(blob_path)
    os.makedirs(input_folder, exist_ok=True)
    local_path = os.path.join(input_folder, filename)

    async with BlobServiceClient.from_connection_string(AZURE_STORAGE_CONNECTION_STRING) as service:
        container_client = service.get_container_client(container)
        blob_client = container_client.get_blob_client(blob_path)
        try:
            await blob_client.get_blob_properties()
        except ResourceNotFoundError:
            raise FileNotFoundError(f"Blob not found: container={container} blob={blob_path}")
        stream = await blob_client.download_blob()
        data = await stream.readall()

    # write file async
    async with aiofiles.open(local_path, "wb") as f:
        await f.write(data)

    return local_path


main.py


from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
import uvicorn
from file_router import router as file_router

def apply_cors(app: FastAPI):
    app.add_middleware(
        CORSMiddleware,
        allow_origins=["*"],
        allow_methods=["*"],
        allow_headers=["*"],
    )

app = FastAPI(title="Layout Detection MCP API", version="0.1.0")
apply_cors(app)
app.include_router(file_router, prefix="/api/v1/layout")

if __name__ == "__main__":
    uvicorn.run("main:app", host="0.0.0.0", port=8667, reload=False)


