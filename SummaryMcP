Got it — we’ll stop trying to heuristically strip the email. Instead we’ll pass the raw email body into the LLM prompt and explicitly instruct the model to use only the main content (ignore salutations/signatures/contact lines) when it decides to include email details in the submission summary.

Below I give a drop-in patch: a small, safe change to newsummary.py (only the relevant functions) plus a short snippet showing how to call it from summary_handler.py. This code:
	•	reads email_body/body_<REF>.txt files for references found in attachments,
	•	passes the raw content to the prompt (truncated for safety),
	•	instructs the LLM to ignore greetings/signatures and use only the main content if relevant.

You already have the beautify_extracted_data producing reference_number in items, so this integrates directly.

⸻

Changes to newsummary.py (replace or merge)

# newsummary.py (only required functions shown / merge into your file)
from dotenv import load_dotenv
import os
import json
from typing import List, Dict, Optional
from openai import AzureOpenAI

load_dotenv()
AZURE_OPENAI_ENDPOINT = os.getenv("AZURE_OPENAI_ENDPOINT")
AZURE_OPENAI_API_VERSION = os.getenv("AZURE_OPENAI_API_VERSION")
AZURE_OPENAI_API_KEY = os.getenv("AZURE_OPENAI_API_KEY")
AZURE_OPENAI_CHAT_DEPLOYMENT = os.getenv("AZURE_OPENAI_CHAT_DEPLOYMENT")

if not (
    AZURE_OPENAI_ENDPOINT
    and AZURE_OPENAI_API_VERSION
    and AZURE_OPENAI_API_KEY
    and AZURE_OPENAI_CHAT_DEPLOYMENT
):
    raise RuntimeError("Azure OpenAI env vars missing.")

client = AzureOpenAI(
    api_key=AZURE_OPENAI_API_KEY,
    api_version=AZURE_OPENAI_API_VERSION,
    azure_endpoint=AZURE_OPENAI_ENDPOINT,
)


def extract_refs_from_attachments(attachments: List[Dict]) -> List[str]:
    """Return unique refs from filenames (text before first underscore)."""
    refs = []
    for item in attachments or []:
        fname = item.get("file_name", "") or ""
        if "_" in fname:
            refs.append(fname.split("_", 1)[0])
    # keep unique in order
    seen = set()
    out = []
    for r in refs:
        if r not in seen:
            seen.add(r)
            out.append(r)
    return out


def load_raw_email_bodies_for_refs(refs: List[str], email_body_folder: str = "email_body") -> Dict[str, Dict]:
    """
    Load raw files named `body_<ref>.txt` from email_body_folder.
    Returns dict: ref -> {"status": "ok", "path": ..., "raw": "<full text>"} or {"status":"missing"}
    """
    base = os.path.dirname(os.path.abspath(__file__))
    out = {}
    for ref in refs or []:
        fname = f"body_{ref}.txt"
        path = os.path.join(base, email_body_folder, fname)
        if not os.path.exists(path):
            out[ref] = {"status": "missing", "path": path}
            continue
        try:
            with open(path, "r", encoding="utf-8", errors="ignore") as f:
                raw = f.read()
            out[ref] = {"status": "ok", "path": path, "raw": raw}
        except Exception as e:
            out[ref] = {"status": "error", "path": path, "error": str(e)}
    return out


def summarize_attachments(
    attachments: List[Dict],
    email_bodies: Optional[Dict[str, Dict]] = None,
    include_email_bodies_in_prompt: bool = True,
) -> str:
    """
    Build combined submission summary. If email_bodies is None, this function
    will attempt to load body_<ref>.txt for refs extracted from attachments.
    We pass raw email text to the LLM and instruct it to use only the main content
    (ignore salutations/signatures/contact lines) when including info.
    """
    # build attachments text
    attachment_chunks = []
    for item in attachments:
        file_name = item.get("file_name", "unknown_file")
        summary_text = item.get("summary", "")
        chunk = f"FILENAME: {file_name}\nSUMMARY: {summary_text}"
        attachment_chunks.append(chunk)
    attachments_text = "\n\n".join(attachment_chunks)
    attachments_text = attachments_text[:8000]

    # load email bodies if not provided
    if email_bodies is None:
        refs = extract_refs_from_attachments(attachments)
        email_bodies = load_raw_email_bodies_for_refs(refs)

    # build email body section for prompt (raw)
    email_chunks = []
    if include_email_bodies_in_prompt and isinstance(email_bodies, dict):
        for ref, meta in email_bodies.items():
            if meta.get("status") == "ok":
                raw = meta.get("raw", "") or ""
                # keep reasonable amount
                snippet = raw[:3000]
                email_chunks.append(f"REFERENCE: {ref}\nRAW_EMAIL_BODY:\n{snippet}")
    email_bodies_text = "\n\n---\n\n".join(email_chunks)
    if len(email_bodies_text) > 6000:
        email_bodies_text = email_bodies_text[:6000] + "\n[TRUNCATED]"

    # final prompt: instruct model to ignore salutations/signatures and use main content only if relevant
    prompt = f"""
You are an experienced Commercial Insurance Underwriter.

You are given multiple attachment documents (file names + short summaries) for a single submission.
Additionally you may be given the RAW email body text(s) that accompanied the submission.

INSTRUCTIONS ABOUT EMAIL BODIES:
- The email bodies are raw; DO NOT assume they are perfectly formatted.
- When using email text, use **only the main content** (i.e. the core submission details, requested limits, dates, TIV, etc.).
  Ignore salutations ("Dear...", "Hi ..."), sign-offs ("Regards", "Kind regards", signatures), and contact lines (email addresses, phone numbers).
- You may incorporate email-provided numeric details (e.g. requested limits, effective dates) into the appropriate section of the summary
  BUT DO NOT invent anything not present in the attachments or emails.

STRUCTURE OF OUTPUT (USE THIS TEMPLATE EXACTLY):

SUBMISSION SUMMARY  
Client: [Client Legal Name]  
Date: [Submission or Document Date]

1. SUBMISSION COVER LETTER / NARRATIVE  
 Exposure Description:  
    - [Describe business / operations]  
    - [Property details if present]  

 Placement Strategy:  
    - [Program / carrier / broker if evident]  

 Renewal Highlights:  
    - [If any]  

 Changes YOY:  
    - [If any]  

 Additional Overview Details:  
    - Effective Date: [if present]  
    - Submission Type: [New / Renewal / Other]  
    - Current Situation: [as stated]

2. LOSS HISTORY PACKAGE  
 5–10 Year Loss Runs:  
    - [Summary if present]  

 Large Loss Details:  
    - [Significant claims]  

 Trends Analysis:  
    - [If present]  

 Summary of Loss History:  
    - Status: [Clean / Losses Reported]  
    - Summary: [one-liner]  
    - Major Incidents: [largest incident if present]

3. EXPOSURE DATA  
 COPE Information:  
    - [Construction, Occupancy, Protection, Exposure]  

 Statement of Values (SOV):  
    - Total Insurable Value (TIV): $[Insert if present]  
    - Building Limit: $[Insert]  
    - Contents/BPP Limit: $[Insert]  
    - Business Income: $[Insert]  

 Financials:  
    - [Any financial info]

CAT Worksheets, Specialty schedules, etc. as needed.

Attached files included:
{attachments_text}

# RAW EMAIL BODIES (if present; use them only to supplement / clarify)
{email_bodies_text}
    """

    response = client.chat.completions.create(
        model=AZURE_OPENAI_CHAT_DEPLOYMENT,
        messages=[{"role": "user", "content": prompt}],
        max_tokens=1024,
        temperature=0.2,
    )

    try:
        return response.choices[0].message.content.strip()
    except Exception:
        return getattr(response.choices[0].message, "content", "").strip()


⸻

How to call from summary_handler.py

After you have beautify_data (which is the list returned by beautify_extracted_data), do this (example snippet):

# summary_handler.py (place near where you currently call summarize_attachments)
from newsummary import extract_refs_from_attachments, load_raw_email_bodies_for_refs, summarize_attachments

# assume filenamesummary_extracted_beautified is the list from extract_filenames_and_summaries(...)
refs = extract_refs_from_attachments(filenamesummary_extracted_beautified)
email_bodies_map = load_raw_email_bodies_for_refs(refs, email_body_folder="email_body")

# pass the email bodies explicitly (safer for debugging)
combined_summary_text = summarize_attachments(filenamesummary_extracted_beautified, email_bodies=email_bodies_map)

If you’d rather let summarize_attachments autoload, you can continue to call it with a single argument.

⸻

Notes & safety
	•	We still truncate bodies to avoid huge prompts (you can raise/lower the 3000/6000 char limits).
	•	The LLM is explicitly told to ignore salutations/signatures/contact lines; this usually works well.
	•	This keeps all email text available (raw) so nothing important is accidentally removed by heuristics.
	•	If you want, I can also show a small local test that prints the prompt (without calling LLM) so you can verify the exact email content being sent.

Would you like that test snippet so you can inspect prompts before model calls?
