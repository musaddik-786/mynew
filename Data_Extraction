here generate something so that it should cause error such that none could resolve it easily 

file_router.py



from fastapi import APIRouter
from fastapi.responses import JSONResponse
from pydantic import BaseModel
# from handler import extract_sanction_status
import traceback
import sys


from fastapi import APIRouter
from fastapi.responses import JSONResponse
from pydantic import BaseModel
from handler import process_sanction_and_eligibility

router = APIRouter()


class LicensingSanctionMCPRequest(BaseModel):
    jsonrpc: str
    id: int
    result: dict


@router.post(
    "/Licensing_&_Sanction_Checker_MCP",
    operation_id="Licensing_&_Sanction_Checker_MCP"
)
async def licensing_sanction_checker_mcp(request: LicensingSanctionMCPRequest):

    decision = process_sanction_and_eligibility(request.result)

    return JSONResponse(
        content={
            "jsonrpc": request.jsonrpc,
            "id": request.id,
            "result": decision
        },
        status_code=200
    )


handler.py


# from service import _require_env, _parse_blob_url
from sqlmodel import Session, select
from models import RefEligibilityCheck ,  AgentSubmissionIntake, AgentEligibility
from db import get_engine
from datetime import datetime
from zoneinfo import ZoneInfo


def process_sanction_and_eligibility(mcp_result: dict) -> dict:
    """
    1. Extract is_Sanctioned (NO DEFAULTS)
    2. Decide Eligible / Not Eligible
    3. Fetch rule from ref_eligibility_check
    4. Fetch latest reference_number from agent_submission_intake
    5. Insert into agent_eligibility
    6. Return combined response
    """

    # ---------- VALIDATION ----------
    if not isinstance(mcp_result, dict):
        return {
            "status": False,
            "error": "Invalid MCP result format (expected dict)"
        }

    results = mcp_result.get("results")
    if not isinstance(results, list) or not results:
        return {
            "status": False,
            "error": "'results' missing or empty in MCP response"
        }

    record = results[0]

    if "is_Sanctioned" not in record:
        return {
            "status": False,
            "error": "'is_Sanctioned' field missing in MCP response"
        }

    is_sanctioned = record["is_Sanctioned"]

    if not isinstance(is_sanctioned, bool):
        return {
            "status": False,
            "error": "'is_Sanctioned' must be boolean"
        }

    # ---------- DECISION ----------
    eligibility_status = "Not Eligible" if is_sanctioned else "Eligible"

    # ---------- DB FETCH ----------
    engine = get_engine()
    with Session(engine) as session:


        # ---------- FETCH LATEST reference_number ----------
        latest_ref_stmt = (
            select(AgentSubmissionIntake)
            .order_by(AgentSubmissionIntake.id.desc())
        )
        latest_submission = session.exec(latest_ref_stmt).first()

        if not latest_submission or not latest_submission.reference_number:
            return {
                "status": False,
                "error": "No reference_number found in agent_submission_intake"
            }

        reference_number = latest_submission.reference_number



        stmt = select(RefEligibilityCheck).where(
            RefEligibilityCheck.eligibility_status == eligibility_status
        )
        row = session.exec(stmt).first()

        if not row:
            return {
                "status": False,
                "error": f"No row found for Eligibility Status = '{eligibility_status}'"
            }

        try: 
            # now = datetime.now()

            # formatted_datetime = now.strftime("%d%m%Y %I:%M:%S %p")
            # now_ist = datetime.now(ZoneInfo("Asia/Kolkata"))
            india_tz = ZoneInfo("Asia/Kolkata")
            current_time_ist = datetime.now(india_tz)
            formatted_time = current_time_ist.strftime('%Y-%m-%d %H:%M:%S')
            # formatted_datetime = now_ist.strftime("%d%m%Y %I:%M:%S %p")
        
        except Exception as e:
            return{
            "status" : False,
            "error": f"Error generating date and time: {e}"
            }


        agent_row = AgentEligibility(
           reference_number=reference_number,
           eligibility_status=row.eligibility_status,
           reason_summary=row.reason_summary,
           line_of_business=row.line_of_business,
           location_risk_zone=row.location_risk_zone,
           business_type=row.business_type,
           licensing_and_sanction_check=row.licensing_and_sanction_check,
           source_of_check=row.source_of_check,
           approval_flag = row.approval_flag,
           eligibility_check_date_time= formatted_time
        )

        session.add(agent_row)
        session.commit()
        session.refresh(agent_row)



        # ---------- RESPONSE ----------
        return {
            "status": True,
            "reference_number" : reference_number,
            "eligibility_status": row.eligibility_status,
            "reason_summary": row.reason_summary,
            "line_of_business": row.line_of_business,
            "location_risk_zone": row.location_risk_zone,
            "business_type": row.business_type,
            "licensing_and_sanction_check": row.licensing_and_sanction_check,
            "source_of_check": row.source_of_check,
            "approval_flag": row.approval_flag,
            "eligibility_check_date_time": formatted_time
        }


main.py



from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from fastapi_mcp import FastApiMCP
import uvicorn

from file_router import router as file_router


def apply_cors(app: FastAPI):
    app.add_middleware(
        CORSMiddleware,
        allow_origins=["*"],
        allow_methods=["*"],
        allow_headers=["*"],
    )


def create_sub_app(title: str, description: str, version: str = "0.1.0") -> FastAPI:
    sub = FastAPI(title=title, description=description, version=version)
    apply_cors(sub)
    return sub


app = FastAPI()
apply_cors(app)

file_app = create_sub_app(
    title="Licensing & Sanction Checker MCP",
    description="Receives JSON blob URL from Data Extraction Agent and compares extracted name with local sanctions CSV."
)
file_app.include_router(file_router)

# Expose ONLY this operation id via MCP HTTP (client will use transport='http')
FastApiMCP(file_app, include_operations=["Licensing_&_Sanction_Checker_MCP"]).mount_http()

# Mount the sub-app under this prefix (keep as-is per your request)
app.mount("/api/v1/eligibility_agent", file_app)


if __name__ == "__main__":
    uvicorn.run(app, host="0.0.0.0", port=8601)



db.py

import os
from sqlmodel import create_engine
from sqlalchemy.pool import NullPool
from dotenv import load_dotenv

load_dotenv()


def get_engine():
    return create_engine(
        f"postgresql+psycopg://{os.getenv('PGUSER')}:{os.getenv('PGPASSWORD')}"
        f"@{os.getenv('PGHOST')}:{os.getenv('PGPORT', '5432')}/{os.getenv('PGDATABASE')}",
        poolclass=NullPool,
        echo=False
    )


models.py

from sqlmodel import SQLModel, Field
from sqlalchemy import Column, String, Boolean
from typing import Optional



# from typing import Optional
from datetime import datetime
from sqlalchemy import Column, TIMESTAMP
# from sqlmodel import SQLModel, Field



class RefEligibilityCheck(SQLModel, table=True):
    __tablename__ = "ref_eligibility_check"


    id: Optional[int] = Field(default=None, primary_key = True)
    
    reason_summary: Optional[str] = Field(
        sa_column=Column("reason_summary", String)
    )

    line_of_business: Optional[str] = Field(
        sa_column=Column("line_of_business", String)
    )

    location_risk_zone: Optional[str] = Field(
        sa_column=Column("location_risk_zone", String)
    )

    business_type: Optional[str] = Field(
        sa_column=Column("business_type", String)
    )

    licensing_and_sanction_check: Optional[str] = Field(
        sa_column=Column("licensing_sanction_check", String)
    )

    source_of_check: Optional[str] = Field(
        sa_column=Column("source_of_check", String)
    )

    eligibility_status: Optional[str] = Field(
        sa_column=Column("eligibility_status", String)
    )

    approval_flag: Optional[bool] = Field(
        sa_column=Column("approval_flag", Boolean)
    )

class AgentSubmissionIntake(SQLModel, table=True):
    __tablename__ = "agent_submission_intake"

    id:Optional[int] = Field(default=None, primary_key=True)

    reference_number: Optional[str] = Field(default=None)


class AgentEligibility(SQLModel, table=True):
    __tablename__="agent_eligibility"

    id: Optional [int] = Field(default = None, primary_key = True)

    reference_number: Optional[str] = Field(
    sa_column=Column("reference_number", String)
    )

    eligibility_status: Optional[str] = Field(
        sa_column=Column("eligibility_status", String)
    )  

    reason_summary: Optional[str] = Field(
        sa_column=Column("reason_summary", String)
    )

    line_of_business: Optional[str] = Field(
       sa_column=Column("line_of_business", String)
   )

    location_risk_zone: Optional[str] = Field(
       sa_column=Column("location_risk_zone", String)
   )

    business_type: Optional[str] = Field(
       sa_column=Column("business_type", String)
   )   
 
    licensing_and_sanction_check: Optional[str] = Field(
       sa_column=Column("licensing_sanction_check", String)
   )

    source_of_check: Optional[str] = Field(
       sa_column=Column("source_of_check", String)
   )

    approval_flag: Optional[bool] = Field(
       sa_column=Column("approval_flag", Boolean)
   )

    eligibility_check_date_time : Optional[datetime] = Field(
    default=None,
    sa_column=Column("eligibility_check_date_time", TIMESTAMP)
   )
