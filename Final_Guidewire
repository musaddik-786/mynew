I am having few more chages that i did 
below is guidewire_client.py

import requests

BASE_URL = "cannot share with you gpt"

HEADERS = {
    "Content-Type": "cannot share with you gpt",
    "accept": "cannot share with you gpt",
    "authorization": "cannot share with you gpt"
}

def post(uri: str, body: dict):
    response = requests.post(BASE_URL + uri, json=body, headers=HEADERS)
    response.raise_for_status()
    return response.json()


document_mapper.py
from models.model_data import QuoteData

def map_document_to_model_data(doc: dict) -> QuoteData:
    insured = doc.get("Insured Information", {})
    broker = doc.get("Broker and Producer Information", {})
    location = doc.get("Property Location", {})
    policy = doc.get("Coverage and Policy Details", {})

    return QuoteData(
        company_name=insured.get("Named Insured (Company Name)"),
        organization_type=insured.get("Organization Type", "").lower(),

        address_line1=location.get("Address Line 1"),
        city=location.get("City"),
        state=location.get("State"),
        postal_code=location.get("Zip Code"),

        producer_code=broker.get("Producer Code"),
        job_effective_date=policy.get("Effective Date"),
    )

model_data.py
from dataclasses import dataclass
@dataclass
class QuoteData:
    company_name:str
    organization_type:str

    address_line1:str
    city: str
    state: str
    postal_code: str

    producer_code : str
    job_effective_date: str


here i want the producer code already set to a value "hq:6"

account_payload.py
from models.model_data import QuoteData

def build_account_payload(data: QuoteData) -> dict:
    return {
        "data": {
            "attributes": {
                "initialAccountHolder": {
                    "contactSubtype": "Company",
                    "companyName": data.company_name,
                    "primaryAddress": {
                        "addressLine1": data.address_line1,
                        "city": data.city,
                        "postalCode": data.postal_code,
                        "state": {
                            "code": data.state[:2].upper()
                        }
                    }
                },
                "initialPrimaryLocation": {
                    "addressLine1": data.address_line1,
                    "city": data.city,
                    "postalCode": data.postal_code,
                    "state": {
                        "code": data.state[:2].upper()
                        }
                },
                "producerCodes": [
                    {"id": "hq:6"}
                ],
                "organizationType": {
                    "code": data.organization_type
                }
            }
        }
    }

coverage_payload.py
def get_coverages():
    return [
        {
            "clauseType": "coverage",
            "id": "GCPPropertyOffPrem",
            "pattern": {"id": "GCPPropertyOffPrem"},
            "terms": {
                "GCPPropertyOffPremDeductible": {"directValue": "50000.00"},
                "GCPPropertyOffPremInterContinent": {"directValue": "50000.00"},
                "GCPPropertyOffPremLimit": {"directValue": "400000.00"},
                "GCPPropertyOffPremWithinTerrLimit": {"directValue": "25000.00"}
            }
        }
   ]

job_payload.py
from models.model_data import QuoteData

def build_job_payload(account_id: str, data: QuoteData) -> dict:
    return {
        "data": {
            "attributes": {
                "account": {
                    "id": account_id
                },
                "baseState": {
                    "code": data.state[:2].upper()
                },
                "jobEffectiveDate": data.job_effective_date,
                "product": {
                    "id": "GoCommercialProp"
                },
                "producerCode": {
                    "id": "pc6"
                }
            }
        }
    }

Location_payload.py
from models.model_data import QuoteData

def build_location_payload(data: QuoteData) -> dict:
    return {
        "data": {
            "attributes": {
                "addressLine1": data.address_line1,
                "city": data.city,
                "postalCode": data.postal_code,
                "state": {
                    "code": data.state[:2].upper()
                },
                "coverableJurisdiction": {
                    "code": data.state[:2].upper(),
                    # "name": data.state
                }
            }
        }
    }


# handler.py
from typing import Dict, Any
from service import _require_env
from storage_utils import read_json_from_blob
from mappers.document_mapper import map_document_to_model_data
from payload_builders.account_payload import build_account_payload
from payload_builders.job_payload import build_job_payload
from payload_builders.location_payload import build_location_payload
from payload_builders.coverage_payloads import get_coverages
from clients.guidewire_client import post


async def guidewire_api_call(blob_url: str) -> Dict[str, Any]:
    """
    Reads JSON directly from Azure Blob and calls Guidewire APIs to get the Quote.
    """
    try:
        _require_env()
    except Exception as e:
        return {"status": False, "error": f"Environment misconfigured: {e}"}

    try:
        document = await read_json_from_blob(blob_url)
        print(document)
    except Exception as e:
        return {"status": False, "error": f"Failed to read blob: {e}"}
    
    try:
        canonical = map_document_to_model_data(document)
    
    except Exception as e:
        return {"status": False, "error": f"Failed to map data : {e}"}

        # canonical = map_document_to_canonical(document)
    account_resp = post("/account/v1/accounts", build_account_payload(canonical))
    account_id = account_resp["data"]["attributes"]["id"]
    
    job_resp = post("/job/v1/submissions", build_job_payload(account_id, canonical))
    job_id = job_resp["data"]["attributes"]["id"]

    location_resp = post(
        f"/job/v1/jobs/{job_id}/lines/GOCommercialLine/locations",
        build_location_payload(canonical)
    )
    location_id = location_resp["data"]["attributes"]["id"]

    for coverage in get_coverages():
        post(
            f"/job/v1/jobs/{job_id}/lines/GOCommercialLine/coverages",
            {"data": {"attributes": coverage}}
        )

    quote_resp = post(f"/job/v1/jobs/{job_id}/quote", {})

    return {
        "status": True,
        "accountId": account_id,
        "jobId": job_id,
        "locationId": location_id,
        "quote": quote_resp
    }

main.py

from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from fastapi_mcp import FastApiMCP
import uvicorn

from router import router as file_router


def apply_cors(app: FastAPI):
    app.add_middleware(
        CORSMiddleware,
        allow_origins=["*"],
        allow_methods=["*"],
        allow_headers=["*"],
    )


def create_sub_app(title: str, description: str, version: str = "0.1.0") -> FastAPI:
    sub = FastAPI(title=title, description=description, version=version)
    apply_cors(sub)
    return sub


app = FastAPI()
apply_cors(app)

file_app = create_sub_app(
    title="Guide wire Integration",
    description="Receives Response from Licensing_&Sanction_Check_MCP andreceives a JSON-RPC request from the Licensing & Sanction Checker MCP containing the `is_Sanctioned` flag. Based on this value, it reads the ref_eligibility_check Table and writes corresponding data into agent_eligibility Table."
)
file_app.include_router(file_router)

# Expose ONLY this operation id via MCP HTTP (client will use transport='http')
FastApiMCP(file_app, include_operations=["Guidewire_Integration"]).mount_http()

# Mount the sub-app under this prefix (keep as-is per your request)
# app.mount("/api/v1/eligibility_agent", file_app)
app.mount("/api/v1/layout", file_app)


if __name__ == "__main__":
    uvicorn.run(app, host="0.0.0.0", port=8601)


router.py

from fastapi import APIRouter
from fastapi.responses import JSONResponse
from pydantic import BaseModel, Field
from handler import guidewire_api_call

router = APIRouter()

class LayoutDetectRequest(BaseModel):
    attachment_url: str = Field(..., description="Full Azure Blob URL to the PDF attachment.")

@router.post("/Guidewire_Integration", operation_id="Guidewire_Integration",
             summary="Download PDF from blob, analyze layout using Form Recognizer, and classify layout")
async def detect_layout(request: LayoutDetectRequest):
    """Downloades the blob based on blob url and calls the Guidewire API with the data present in the blob for Quote generation

    
    Args:
        attachment_url: The Blob URL oreturned by the email_attachment_mcp
    
    Returns:
        JSONResponse: returns the json response containing Quote generated.
    """
    try:
        result = await guidewire_api_call(request.attachment_url)
        return JSONResponse(content={"jsonrpc": "2.0", "id": 1, "result": result}, status_code=200)
    except Exception as e:
        return JSONResponse(content={"jsonrpc": "2.0", "id": 1,
                                     "result": {"status": False, "error": str(e)}}, status_code=200)

service.py
# service.py
#Working code 

import os
from urllib.parse import urlparse, unquote
from dotenv import load_dotenv

load_dotenv()

AZURE_STORAGE_CONNECTION_STRING = os.environ.get("AZURE_STORAGE_CONNECTION_STRING", "")

def _require_env() -> None:
    """Ensure required environment variables exist."""
    if not AZURE_STORAGE_CONNECTION_STRING:
        raise RuntimeError("Missing AZURE_STORAGE_CONNECTION_STRING in environment/.env")

def _parse_blob_url(url: str) -> tuple[str, str]:
    """
    Parse an Azure Blob URL and return (container_name, blob_path).
    Example URL:
      https://account.blob.core.windows.net/output-results/folder/name.pdf
    Returns:
      ("output-results", "folder/name.pdf")
    """
    parsed = urlparse(url)
    if not parsed.scheme.startswith("http"):
        raise ValueError("url must be a valid http(s) Azure Blob URL.")

    path = parsed.path.lstrip("/")
    if "/" not in path:
        raise ValueError("url must include both container and blob path.")
    parts = path.split("/", 1)
    container = parts[0]
    blob_path = parts[1]
    return unquote(container), unquote(blob_path)



# storage_utils.py
import json
from azure.storage.blob.aio import BlobServiceClient
from azure.core.exceptions import ResourceNotFoundError
from service import AZURE_STORAGE_CONNECTION_STRING, _parse_blob_url


async def read_json_from_blob(blob_url: str) -> dict:
    """
    Reads a JSON file directly from Azure Blob Storage and returns it as dict.
    No local file system usage.
    """
    if not AZURE_STORAGE_CONNECTION_STRING:
        raise RuntimeError("AZURE_STORAGE_CONNECTION_STRING not set")

    container, blob_path = _parse_blob_url(blob_url)

    async with BlobServiceClient.from_connection_string(
        AZURE_STORAGE_CONNECTION_STRING
    ) as service:
        container_client = service.get_container_client(container)
        blob_client = container_client.get_blob_client(blob_path)

        try:
            await blob_client.get_blob_properties()
        except ResourceNotFoundError:
            raise FileNotFoundError(
                f"Blob not found: container={container}, blob={blob_path}"
            )

        stream = await blob_client.download_blob()
        raw_bytes = await stream.readall()

    return json.loads(raw_bytes.decode("utf-8"))



# test_scripts.py
import requests
import json

BASE_URL = "http://localhost:8601/api/v1/layout/Guidewire_Integration"

def run_test():
    payload = {
        #   "attachment_url": "https://agenticai1.blob.core.windows.net/attachment-downloader/19BDB64178C5A9C8_attachment_Acord_125_High_tech_solution.pdf" , 
        "attachment_url"  :  "https://agenticai1.blob.core.windows.net/output-results/ManufacturingFacility_SubmissionDocument_For_Quote_extraction_20260130_081421.json"

    }


    try:
        resp = requests.post(BASE_URL, json=payload, timeout=180)
        print("HTTP Status:", resp.status_code)
        try:
            data = resp.json()
            print(json.dumps(data, indent=4))
        except Exception:
            print("Response not JSON:", resp.text)
    except Exception as e:
        print("Error calling API:", str(e))

if __name__ == "__main__":
    print("Testing /layout_detection_mcp ...")
    run_test()

error:
Testing /layout_detection_mcp ...
HTTP Status: 200
{
    "jsonrpc": "2.0",
    "id": 1,
    "result": {
        "status": false,
        "error": "400 Client Error:  for url: https://pc-sandbox-g/account/v1/accounts
