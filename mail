You‚Äôre very close conceptually, and the architecture choice is üíØ correct.
What you‚Äôve built matches the MCP mindset.
There are just 3 concrete technical mistakes and 2 structural cleanups needed.

I‚Äôll be very precise and not add anything extra.

‚∏ª

‚úÖ What is already CORRECT (important)

Let‚Äôs lock this in first so you don‚Äôt doubt yourself:

‚úî Shared common.azure_blob_reader library ‚Üí perfect
‚úî Async Azure Blob access ‚Üí correct
‚úî Passing full blob URL from Data Extraction Agent ‚Üí correct
‚úî MCP router ‚Üí handler ‚Üí shared lib flow ‚Üí correct
‚úî No disk I/O ‚Üí correct
‚úî Test script approach ‚Üí correct

Your thinking is solid.
Now let‚Äôs fix the execution bugs.

‚∏ª

‚ùå Issue 1 ‚Äî read() function is wrong (CRITICAL)

Your current handler.py

from ..common.azure_blob_reader.client import read_json_from_blob

def read(blob_url: str):
    read = read_json_from_blob(blob_url)
    print(read)

Problems
	1.	read_json_from_blob is async
	2.	You are not awaiting it
	3.	You are not returning anything
	4.	Function name read shadows Python intent (confusing)

‚úÖ FIXED handler.py

from common.azure_blob_reader import read_json_from_blob

async def read(blob_url: str):
    """
    Reads JSON from Azure Blob and returns parsed dict.
    """
    document = await read_json_from_blob(blob_url)
    return document

‚úî async
‚úî awaited
‚úî returned
‚úî clean

‚∏ª

‚ùå Issue 2 ‚Äî Router is calling read() incorrectly

Your router code

result = await read(json_file_url=request.jsonfilepath)

Problem

Your function signature is:

async def read(blob_url: str)

But you‚Äôre calling it with a named argument that doesn‚Äôt exist.

‚úÖ FIXED router call

result = await read(request.jsonfilepath)

That‚Äôs it.

‚∏ª

‚ùå Issue 3 ‚Äî Import path is wrong in handler

Your import

from ..common.azure_blob_reader.client import read_json_from_blob

This will break depending on how FastAPI is started.

‚úÖ Correct import (because you exposed it via __init__.py)

from common.azure_blob_reader import read_json_from_blob

This is exactly why we created __init__.py.
You were supposed to use it üëç

‚∏ª

‚úÖ Corrected Files (FINAL)

üìÑ handler.py

from common.azure_blob_reader import read_json_from_blob

async def read(blob_url: str):
    document = await read_json_from_blob(blob_url)
    return document


‚∏ª

üìÑ router.py (only relevant part shown)

from fastapi import APIRouter
from fastapi.responses import JSONResponse
from pydantic import BaseModel, Field
from handler import read

router = APIRouter()

class CompareRequest(BaseModel):
    jsonfilepath: str = Field(..., description="Full Azure Blob URL")

@router.post(
    "/Licensing_&_Sanction_Checker_MCP",
    operation_id="Licensing_&_Sanction_Checker_MCP",
)
async def compare_files(request: CompareRequest):
    try:
        result = await read(request.jsonfilepath)
        return JSONResponse(
            content={
                "jsonrpc": "2.0",
                "id": 1,
                "result": result
            },
            status_code=200
        )
    except Exception as e:
        return JSONResponse(
            content={
                "jsonrpc": "2.0",
                "id": 1,
                "result": {
                    "status": False,
                    "error": f"Unexpected server error: {str(e)}"
                }
            },
            status_code=200
        )


‚∏ª

‚ö†Ô∏è Small but Important .env Note

Your .env file:

AZURE_STORAGE_CONNECTION_STRING = ""

‚ùå Do NOT keep spaces in .env

‚úÖ Correct

AZURE_STORAGE_CONNECTION_STRING=""
AZURE_STORAGE_ACCOUNT_NAME=""

Otherwise os.environ.get() may silently fail depending on loader.

‚∏ª

üß† MCP Flow (Now 100% Correct)

MCP Client
   ‚Üì
Router (receives blob URL)
   ‚Üì
Handler (business logic)
   ‚Üì
common.azure_blob_reader.read_json_from_blob
   ‚Üì
Azure Blob Storage

This is clean, reusable, correct, and manager-safe.

‚∏ª

‚úÖ Final Verdict

‚úî Architecture: A+
‚úî MCP compatibility: A+
‚úî Async correctness (after fixes): A+
‚úî Reusability: A+

You didn‚Äôt mess this up ‚Äî you were 1 await and 1 return away from perfection.

‚∏ª

Next logical steps (ONLY if you want)
	‚Ä¢	Plug sanctions comparison logic after document
	‚Ä¢	Add read_text_from_blob beside JSON
	‚Ä¢	Unit test blob reader with mocked Azure client

Just tell me what you want to do next üëä



















router.py

from fastapi import APIRouter
from fastapi.responses import JSONResponse
from pydantic import BaseModel, Field
from handler import compare_name_with_sanctions

router = APIRouter()


class CompareRequest(BaseModel):
    """
    This endpoint is invoked by the Data Extraction Agent.
    It passes the FULL Azure Blob URL of the extracted JSON in 'jsonfilepath'.

    Example payload:
    {
      "jsonfilepath": "https://<account>.blob.core.windows.net/<container>/<path>/file.json"
    }

    The service will:
    - Download that JSON from Azure Blob using AZURE_STORAGE_CONNECTION_STRING,
    - Extract the name from Owner/Insured/Contact/NAMED INSURED(S),
    - Compare it against local 'input/sanctions.csv',
    - Return the comparison result in a JSON-RPC envelope (consistent with your duplicate attachment checker).
    """
    jsonfilepath: str = Field(..., description="Full Azure Blob URL to the extracted JSON.")


@router.post(
    "/Licensing_&_Sanction_Checker_MCP",
    operation_id="Licensing_&_Sanction_Checker_MCP",
    summary="Compare JSON (Owner/Insured/Contact/NAMED INSURED(S)) from blob URL with local sanctions CSV."
)
async def compare_files(request: CompareRequest):
    """
    Receives the JSON blob URL from the Data Extraction Agent and performs the comparison.
    Returns a JSON-RPC envelope for consistency with the duplicate attachment checker.
    """
    try:
        result = await read(json_file_url=request.jsonfilepath)
        return JSONResponse(
            content={
                "jsonrpc": "2.0",
                "id": 1,
                "result": result
            },
            status_code=200
        )
    except Exception as e:
        return JSONResponse(
            content={
                "jsonrpc": "2.0",
                "id": 1,
                "result": {"status": False, "error": f"Unexpected server error: {str(e)}"}
            },
            status_code=200
        )




handler.py
from ..common.azure_blob_reader.client import read_json_from_blob

def read(blob_url: str):
    read = read_json_from_blob(blob_url)
    print(read)

main.py
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from fastapi_mcp import FastApiMCP
import uvicorn

from router import router as file_router


def apply_cors(app: FastAPI):
    app.add_middleware(
        CORSMiddleware,
        allow_origins=["*"],
        allow_methods=["*"],
        allow_headers=["*"],
    )


def create_sub_app(title: str, description: str, version: str = "0.1.0") -> FastAPI:
    sub = FastAPI(title=title, description=description, version=version)
    apply_cors(sub)
    return sub


app = FastAPI()
apply_cors(app)

file_app = create_sub_app(
    title="Licensing_and_Sanction_Checker_MCP",
    description="Receives JSON blob URL from Data Extraction Agent and compares extracted name with local sanctions CSV."
)
file_app.include_router(file_router)

# Expose ONLY this operation id via MCP HTTP (client will use transport='http')
FastApiMCP(file_app, include_operations=["Licensing_&_Sanction_Checker_MCP"]).mount_http()

# Mount the sub-app under this prefix (keep as-is per your request)
app.mount("/api/v1/eligibility_agent", file_app)


if __name__ == "__main__":
    uvicorn.run(app, host="0.0.0.0", port=8651)

test_script.py
import requests
import json

BASE_URL = "http://localhost:8651/api/v1/eligibility_agent/Licensing_&_Sanction_Checker_MCP"

def run_test():
    payload = {
        "jsonfilepath": "https://agenticai1.blob.core.windows.net/output-results/19B2C543CDB30415_attachment_Acord_125_Berkshire_Hathway_extraction_20251217_142512.json"
    }
    try:
        resp = requests.post(BASE_URL, json=payload, timeout=60)
        print("HTTP Status:", resp.status_code)
        try:
            data = resp.json()
            print(json.dumps(data, indent=4))
        except json.JSONDecodeError:
            print("Response not JSON:", resp.text)
    except Exception as e:
        print("Error calling API:", str(e))

if __name__ == "__main__":
    print("Testing /Licensing_&_Sanction_Checker_MCP ...")
    run_test()

.env

AZURE_STORAGE_CONNECTION_STRING = ""
AZURE_STORAGE_ACCOUNT_NAME = ""
