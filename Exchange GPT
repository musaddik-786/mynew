Perfect üëç
This is a clean architectural decision and actually better for performance and security.

You want:
	‚Ä¢	‚ùå No downloading JSON to disk
	‚Ä¢	‚úÖ Read JSON directly from Azure Blob
	‚Ä¢	‚úÖ Keep the same API contract
	‚Ä¢	‚úÖ Give COMPLETE working code for ALL files

Below is a FULL END-TO-END REWRITE, minimal changes, no extra complexity, and fully aligned with your current project.

‚∏ª

‚úÖ New High-Level Flow (Updated)

Client calls API
 ‚Üì
Router ‚Üí Handler
 ‚Üì
Handler validates env
 ‚Üì
Read JSON directly from Azure Blob (memory)
 ‚Üì
Map JSON ‚Üí Canonical model
 ‚Üì
Build Guidewire payloads
 ‚Üì
Call Guidewire APIs
 ‚Üì
Return response

üëâ No file system usage at all

‚∏ª

üìÅ Files we will CHANGE
	‚Ä¢	storage_utils.py ‚úÖ (new function)
	‚Ä¢	handler.py ‚úÖ

üìÅ Files that stay SAME
	‚Ä¢	main.py
	‚Ä¢	router.py
	‚Ä¢	service.py
	‚Ä¢	test_script.py
	‚Ä¢	payload builders, mappers, client (from previous steps)

‚∏ª

üîß 1Ô∏è‚É£ storage_utils.py (READ JSON DIRECTLY)

‚úÖ NEW FUNCTION: read_json_from_blob

‚ùå REMOVED: file writing logic

# storage_utils.py
import json
from azure.storage.blob.aio import BlobServiceClient
from azure.core.exceptions import ResourceNotFoundError
from service import AZURE_STORAGE_CONNECTION_STRING, _parse_blob_url


async def read_json_from_blob(blob_url: str) -> dict:
    """
    Reads a JSON file directly from Azure Blob Storage and returns it as dict.
    No local file system usage.
    """
    if not AZURE_STORAGE_CONNECTION_STRING:
        raise RuntimeError("AZURE_STORAGE_CONNECTION_STRING not set")

    container, blob_path = _parse_blob_url(blob_url)

    async with BlobServiceClient.from_connection_string(
        AZURE_STORAGE_CONNECTION_STRING
    ) as service:
        container_client = service.get_container_client(container)
        blob_client = container_client.get_blob_client(blob_path)

        try:
            await blob_client.get_blob_properties()
        except ResourceNotFoundError:
            raise FileNotFoundError(
                f"Blob not found: container={container}, blob={blob_path}"
            )

        stream = await blob_client.download_blob()
        raw_bytes = await stream.readall()

    return json.loads(raw_bytes.decode("utf-8"))


‚∏ª

üîÅ 2Ô∏è‚É£ handler.py (NO DOWNLOAD, DIRECT READ)

‚ùå Removed:
	‚Ä¢	INPUT_FOLDER
	‚Ä¢	download_blob_to_input_folder
	‚Ä¢	file I/O

‚úÖ Uses read_json_from_blob

# handler.py
from typing import Dict, Any
from service import _require_env
from storage_utils import read_json_from_blob

from mappers.document_mapper import map_document_to_canonical
from payload_builders.account_payload import build_account_payload
from payload_builders.job_payload import build_job_payload
from payload_builders.location_payload import build_location_payload
from payload_builders.coverage_payloads import get_coverages
from clients.guidewire_client import post


async def classify_blob_pdf_layout(blob_url: str) -> Dict[str, Any]:
    """
    Reads JSON directly from Azure Blob and calls Guidewire APIs
    """
    try:
        _require_env()
    except Exception as e:
        return {"status": False, "error": f"Environment misconfigured: {e}"}

    try:
        # 1Ô∏è‚É£ Read JSON directly from blob
        document = await read_json_from_blob(blob_url)

        # 2Ô∏è‚É£ Map JSON ‚Üí Canonical model
        canonical = map_document_to_canonical(document)

        # 3Ô∏è‚É£ Create Account
        account_resp = post(
            "/account/v1/accounts",
            build_account_payload(canonical)
        )
        account_id = account_resp["data"]["attributes"]["id"]

        # 4Ô∏è‚É£ Create Job
        job_resp = post(
            "/job/v1/submissions",
            build_job_payload(account_id, canonical)
        )
        job_id = job_resp["data"]["attributes"]["id"]

        # 5Ô∏è‚É£ Create Location
        location_resp = post(
            f"/job/v1/jobs/{job_id}/lines/GOCommercialLine/locations",
            build_location_payload(canonical)
        )
        location_id = location_resp["data"]["attributes"]["id"]

        # 6Ô∏è‚É£ Post Coverages
        for coverage in get_coverages():
            post(
                f"/job/v1/jobs/{job_id}/lines/GOCommercialLine/coverages",
                {"data": {"attributes": coverage}}
            )

        # 7Ô∏è‚É£ Quote
        quote_resp = post(
            f"/job/v1/jobs/{job_id}/quote",
            {}
        )

        return {
            "status": True,
            "accountId": account_id,
            "jobId": job_id,
            "locationId": location_id,
            "quote": quote_resp
        }

    except Exception as e:
        return {"status": False, "error": str(e)}


‚∏ª

üß© 3Ô∏è‚É£ service.py (UNCHANGED)

‚úî Your existing service.py is perfect
‚úî _parse_blob_url is reused
‚úî _require_env still valid

üëâ No changes needed

‚∏ª

üåê 4Ô∏è‚É£ router.py (UNCHANGED)

Works exactly the same ‚Äî still receives attachment_url.

‚∏ª

üöÄ 5Ô∏è‚É£ main.py (UNCHANGED)

No changes required.

‚∏ª

üß™ 6Ô∏è‚É£ test_script.py (UNCHANGED)

Still works exactly the same.

‚∏ª

‚úÖ What You Achieved (IMPORTANT)

‚úî Technical Improvements
	‚Ä¢	No disk I/O
	‚Ä¢	Faster execution
	‚Ä¢	Stateless service
	‚Ä¢	Cloud-native design
	‚Ä¢	Works well in containers & serverless

‚úî Architectural Cleanliness
	‚Ä¢	Storage layer only reads data
	‚Ä¢	Handler orchestrates
	‚Ä¢	No side effects
	‚Ä¢	Easier to test & debug

‚úî Manager-level Win

You can confidently say:

‚ÄúWe now read structured documents directly from Azure Blob into memory and drive downstream underwriting APIs without any intermediate persistence.‚Äù

That‚Äôs enterprise-grade.

‚∏ª

If you want next:
	‚Ä¢	Support both PDF & JSON
	‚Ä¢	Add schema validation
	‚Ä¢	Add retry + circuit breaker
	‚Ä¢	Convert this to Guidewire batch request format

Just tell me üëç
